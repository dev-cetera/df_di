// Consolidated Imports
import 'package:df_di/df_di.dart';
import 'dart:async';
import 'package:test/test.dart';
import 'package:df_di/src/_common.dart';
import 'package:get_it/get_it.dart';
import 'dart:math';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:meta/meta.dart' show protected;
import 'package:df_debouncer/df_debouncer.dart';
import 'package:df_safer_dart/df_safer_dart.dart';
import 'package:equatable/equatable.dart';

// Source: ./dart_example/bin/dart_example.dart
// import 'package:df_di/df_di.dart';

void main(List<String> arguments) {
  final a1 = TypeEntity('minified:Class1377<Object>', [
    'minified:Class1377<Object>',
  ]);
  final b1 = TypeEntity('minified:Class1377<minified:Class1377<Object>>');
  print(a1 == b1); // expected true

  final a2 = TypeEntity(Service<Params>);
  final b2 = TypeEntity(Service, [Params]);
  print(a2 == b2); // expected true

  DI.global.register<List<int>>([42]);
  final answer = DI.global.getT(List<int>).unwrap().unwrap();
  final output = '${List<int>}: $answer';
  print(output);
}

// Testing Object? vs Object.
class Service<TParams extends Object?> {}

class Params extends Object {}

// Source: ./example/until_1.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import 'dart:async';

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() async {
  () async {
    await Future<void>.delayed(const Duration(seconds: 1));
    DI.global.register<_T>(() async {
      await Future<void>.delayed(const Duration(seconds: 1));
      return [
        [42],
      ];
    }());
  }();

  consec(DI.global.untilExactlyT<_T>(_T).value, (e) => print(e));
  consec(DI.global.untilSuper<List<Object>>().value, (e) => print(e));
  consec(DI.global.untilSuper<List<Object>>().value, (e) => print(e));
  consec(DI.global.untilExactlyT<_T>(_T).value, (e) => print(e));
  consec(DI.global.untilExactlyT(_T).value, (e) => print(e));
  consec(DI.global.untilSuper<_T>().value, (e) => print(e));
  consec(DI.global.untilSuper<_T>().value, (e) => print(e));
}

typedef _T = List<List<int>>;

// Source: ./example/issue.dart
// ignore_for_file: unused_local_variable

// import 'package:df_di/df_di.dart';

void register() async {
  await Future<void>.delayed(const Duration(seconds: 1));
  DI.global.register(Child());
  print(DI.global.registry.state);
}

void main() async {
  register();
  print(await DI.global.untilSuper<int>().unwrap());
}

class Grandparent {}

class Parent extends Grandparent {}

class Child extends Parent {}

// Source: ./example/unregister.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() async {
  final di = DI();
  di.register<int>(
    1,
    onUnregister: (value) {
      print('Unregistering value: $value');
      return null;
    },
  );
  di.register<int>(
    2,
    groupEntity: Entity.obj('group2'),
    onUnregister: (value) {
      print('Unregistering value: $value');
      return null;
    },
  );
  // di.unregisterT(
  //   int,
  //   groupEntity: Entity.obj('group2'),
  // );
  di.unregisterAll(
    onBeforeUnregister: (value) {
      print('Before unregistering value: $value');
      return null;
    },
    onAfterUnregister: (value) {
      print('After unregistering value: $value');
      return null;
    },
  );
}

// Source: ./example/example.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() async {
  final di = DI();
  di.registerLazy<String>(() => SyncOk.value('Lazy init!'));
  print(di.getLazySingleton<String>());
  print(di.getLazySingletonUnsafe<String>());
  print(di.getFactory<String>());
  print(di.getFactoryUnsafe<String>());
  print(di.get<Lazy<String>>());
  print(di.getLazy<String>());
  print(di.getLazyUnsafe<String>());
  print('---');
  print(di.getLazySingletonT<String>(String));
  print(di.getLazySingletonUnsafeT<String>(String));
  print(di.getFactoryT<String>(String));
  print(di.getFactoryUnsafeT<String>(String));
  print(di.getT<Lazy<String>>(Lazy<String>));
  print(di.getLazyT<String>(String));
  print(di.getLazyUnsafeT<String>(String));
  di.unregisterLazy<String>();
}

class A {}

class B extends A {}

// Source: ./example/until_2.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async';

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class Test1 {}

class Test2 {}

class Parent3 {}

class Test3 extends Parent3 {}

class Test4 {}

final di = DI();

void setup() async {
  // di.register(Future<Test1>.value(Test1()));
  // await Future<void>.delayed(const Duration(seconds: 1));
  // di.register(Future<Test2>.value(Test2()));
  // await Future<void>.delayed(const Duration(seconds: 1));
  di.register(Future<int>.delayed(const Duration(seconds: 2), () => 1));
}

void main() async {
  // final e = ReservedSafeFinisher<int>(TypeEntity(int));
  // print(e is ReservedSafeFinisher<num>);
  // // print((ReservedSafeFinisher<int>(TypeEntity(int)) is ReservedSafeFinisher<num>));

  //setup();
  Future.delayed(const Duration(seconds: 1), () {
    di.register<num>(Future.delayed(const Duration(seconds: 2), () => 1));
  });

  print(await di.untilSuper<int>().value);

  // final a = ReservedSafeFinisher<int>(TypeEntity(int));
  // print(a is ReservedSafeFinisher<num>);

  // setup();
  // final u2 = di.until<Parent3>();
  // print(await u2.unwrap());
  // print('DONE!!!');
}

// Source: ./example/type_entity.dart
// ignore_for_file: unused_local_variable

// import 'package:df_di/df_di.dart';

void main() {
  // Prints true true
  {
    final a = TypeEntity(Map<String, dynamic>);
    final b = TypeEntity(Map, [String, dynamic]);
    print(a == b);
    final c = TypeEntity(TypeEntity(Map), [String, dynamic]);
    print(a == c);
  }
  // Prints true true
  {
    print(dynamic);
    final a = TypeEntity('${Map<String, dynamic>}');
    final b = TypeEntity('$Map', ['$String', '$dynamic']);
    print(a == b);
    final c = TypeEntity(TypeEntity(Map), ['$String', 'dynamic']);
    print(a == c);
  }
  // // Prints true true - wont work with minification
  // {
  //   final a = TypeEntity('${Map<String, dynamic>}');
  //   final b = TypeEntity('$Map', ['$String', '$dynamic']);
  //   print(a == b);
  //   final c = TypeEntity(TypeEntity('Map'), ['String', 'dynamic']);
  //   print(a == c);
  // }
}

// Source: ./example/until_3.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() async {
  DI.global.register<int>(22);
  print(DI.global.untilSuper<num>().unwrap());
}

// Source: ./tests/world.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: omit_local_variable_types, invalid_use_of_visible_for_testing_member

// import 'package:df_di/df_di.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  // Create a new world for players or users to exist in.
  final world = World();

  // Create a new player in the world.
  final player1 = world.createUniqueEntity();

  // Spawn the player in the world with the components Name, Position and Velocity.
  world.addAllComponents(player1, {
    const Name('Player 1'),
    const Position(x: 0, y: 0),
    const Velocity(x: 1, y: 0),
  });

  // Print the current position.
  final p0 = player1.getComponent<Position>().unwrap();
  print('Position 0: (${p0.x}, ${p0.y})');

  // Update the movement in the world.
  final movementSystem = MovementSystem();
  movementSystem.update(world);

  // Print the position after the world update.
  final p1 = player1.getComponent<Position>().unwrap();
  print('Position 1: (${p1.x}, ${p1.y})');

  // Print the player name.
  final name = player1.getComponent<Name>().unwrap().name;
  print('Player name: "$name"');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

abstract class UpdateSystem {
  void update(World entityManger);
}

class MovementSystem extends UpdateSystem {
  @override
  void update(World entityManger) {
    // Get all entities with both Position and Velocity components.
    final entities = entityManger.query2<Position, Velocity>();
    for (var entity in entities) {
      // Update the position based on the velocity
      final position = entity.getComponent<Position>().unwrap();
      final velocity = entity.getComponent<Velocity>().unwrap();
      final result = entityManger.updateComponent(
        entity,
        position.add(velocity),
      );
      final newPosition = result.unwrap() as Position;

      // Log the updated position.
      print('Updated Position: (${newPosition.x}, ${newPosition.y})');
    }
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class Name extends Component {
  final String name;
  const Name(this.name);

  @override
  List<Object?> get props => [name];
}

class Vector extends Component {
  final double x;
  final double y;
  const Vector({this.x = 0.0, this.y = 0.0});

  Vector add(Vector other) {
    return Vector(x: x + other.x, y: y + other.y);
  }

  @override
  List<Object?> get props => [x, y];
}

class Position extends Vector {
  const Position({super.x = 0.0, super.y = 0.0});

  @override
  Position add(Vector other) {
    return Position(x: x + other.x, y: y + other.y);
  }
}

class Velocity extends Vector {
  const Velocity({super.x = 0.0, super.y = 0.0});

  @override
  Velocity add(Vector other) {
    return Velocity(x: x + other.x, y: y + other.y);
  }
}

// Source: ./tests/until.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async';

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  //  final di = DI();
  // di.register<int>(Future.value(1));
  // print(di.register<int>(Future.value(2)).isErr());
  // print(await di.until<int>().unwrap());
  // print(di.until<num>().unwrap());

  test('Testing the until function with a single registaration.', () async {
    final parent = DI();
    final child = parent.child();

    Future.delayed(const Duration(seconds: 1), () {
      parent.register<int>(Future.value(1));
    });

    print(await child.untilSuper<int>().unwrap());
    print(child.get<int>());
    print(child.get<int>());

    // Future.delayed(const Duration(seconds: 3), () {
    //   di.register(1000);
    // });

    // print(await di.until<String>().unwrap());
    // print(di.until<num>().unwrap());
    // print(di.until<int>().unwrap());
    // print(await di.until<num>().unwrap());
    // print(di.registry.state);
    // print('111');

    // //print(di<SafeFinisher<int>>().unwrap());

    // final a = di.registry
    //     .getDependencies<ReservedSafeFinisher>()
    //     .map((e) => e.value.unwrap())
    //     .cast<ReservedSafeFinisher>();

    // print(a.where((e) {
    //   print(e.resolvable().value as FutureOr<Result<num>>);
    //   print(e.type == int);
    //   return [e] is List<ReservedSafeFinisher<int>>;
    // }));
    // print(a.where((e) => e.type == int));

    // print(await di.until<num>().unwrap());
  });

  // test('Testing the until function.', () async {
  //   final di = DI();
  //   Future.delayed(const Duration(seconds: 1), () => di.register<int>(1));
  //   Future.delayed(
  //     const Duration(seconds: 1),
  //     () => di.register<String>('Hello!'),
  //   );
  //   await di.until<int>().unwrap();
  //   final value = di.until<int>().unwrap();
  //   expect(1, await value);
  //   expect('Hello!', await di.until<String>().unwrap());
  // });
  // test('Testing the untilT function.', () async {
  //   final di = DI();
  //   Future.delayed(const Duration(seconds: 1), () => di.register<int>(1));
  //   Future.delayed(
  //     const Duration(seconds: 1),
  //     () => di.register<String>('Hello!'),
  //   );
  //   await di.untilT(int).unwrap();
  //   final value = di.untilT(int).unwrap();
  //   expect(1, await value);
  //   expect('Hello!', await di.untilT(String).unwrap());
  // });
  // test('Testing the until function with a service.', () async {
  //   final di = DI();
  //   final service = Future<TestService>.delayed(
  //     const Duration(seconds: 1),
  //     () => TestService(),
  //   );
  //   Future.delayed(
  //     const Duration(seconds: 4),
  //     () => di.registerAndInitService<TestService>(service),
  //   );
  //   final value = await di.until<TestService>().unwrap();
  //   expect(await service, value);
  //});
}

base class TestService extends Service {}

// Source: ./tests/until_1.dart
// ignore_for_file: unused_local_variable, invalid_use_of_visible_for_testing_member

// import 'package:df_di/df_di.dart';
// import 'package:test/test.dart';

void main() {
  test('test', () async {
    final u1 = DI.global.untilExactlyT(int);
    final u2 = DI.global.untilExactlyT(double);
    final u3 = DI.global.untilExactlyT(String);
    final u4 = DI.global.untilSuper<int>();
    final u5 = DI.global.untilSuper<double>();
    final u6 = DI.global.untilSuper<String>();
    expect(
      (DI.global.finishersK[const DefaultEntity()]?.map((e) => e.toString()).toList()?..sort())
          .toString(),
      "[Instance of 'ReservedSafeFinisher<Object>', Instance of 'ReservedSafeFinisher<Object>', Instance of 'ReservedSafeFinisher<Object>']",
    );
  });
}

// Source: ./tests/register_and_get.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  test(
    'The value returned by "register" is the same as the value registered',
    () {
      final di = DI();
      final a = <int>[1, 2, 3];
      di.register<List<int>>(a);
      final b = di<Iterable<int>>();
      expect(a, b);
      expect(a.hashCode, b.hashCode);
      di.unregister<Iterable<int>>();
      expect(false, di.isRegistered<List<Object>>());
    },
  );
  /*
  group(
    'Testing basics',
    () {
      test(
        '- The value returned by "register" is the same as the value registered',
        () {
          final di = DI();
          final a = <int>[1, 2, 3];
          final b = di.register<List<int>>(a);
          expect(
            a,
            b,
          );
          expect(
            a.hashCode,
            b.hashCode,
          );
        },
      );

      test(
        '- The exact registered value is returned by "register"',
        () async {
          final di = DI();
          final a = Future<int>.delayed(const Duration(milliseconds: 100), () => 1);
          final b = di.register<int>(a);
          expect(
            1,
            await b,
          );
        },
      );
    },
  );

  group(
    'Testing "register" and "get"',
    () {
      test(
        '- Get with "dynamic" or "Object" should return the first registered value',
        () {
          final di = DI();
          di.register<int>(1);
          di.register<String>('2');
          di.register<bool>(false);
          expect(
            di.getOrNull<int>(),
            1,
          );
        },
      );

      test(
        '- Register "String", get "String"',
        () {
          final di = DI();
          expect(
            di.register<String>('Hello World!'),
            di.getOrNull<String>(),
          );
          expect(
            di.getOrNull<String>(),
            'Hello World!',
          );
        },
      );

      test(
        '- Register "Set<int>", get "Iterable"',
        () {
          final di = DI();
          final a = di.register<Set<int>>({1, 2, 3});
          expect(
            di.getOrNull<Iterable<dynamic>>(),
            a,
          );
          expect(
            di.getOrNull<Iterable<Object>>(),
            a,
          );
          expect(
            di.getOrNull<LinkedHashSet<Object>>(),
            a,
          );
        },
      );

      test(
        '- Register "Map<String, Map<String, int>>, get "Map"',
        () {
          final di = DI();
          final a = <String, Map<String, int>>{
            'a': {
              'b': 3,
            },
          };
          expect(
            di.register<Map<String, Map<String, int>>>(a),
            di.getOrNull<Map<String, Map<String, int>>>(),
          );
          expect(
            di.getOrNull<Map<dynamic, dynamic>>(),
            a,
          );
          expect(
            di.getOrNull<Map<Object, Object>>(),
            a,
          );
          expect(
            di.getOrNull<LinkedHashMap<Object, Object>>(),
            a,
          );
        },
      );
    },
  );

  group(
    'Testing Future registrations',
    () {
      test(
        '- Unregister Futures',
        () async {
          final di = DI();
          final value = Future.value(1);
          di.register(value);
          expect(
            1,
            di.registry.getGroup(groupEntity: di.focusGroup).length,
          );
          final valueGot = await di.getOrNull<int>();
          expect(
            1,
            valueGot,
          );
          expect(
            1,
            di.registry.getGroup(groupEntity: di.focusGroup).length,
          );
        },
      );
    },
  );

  group(
    'Testing unregistering',
    () {
      test(
        '- 1',
        () async {
          final di = DI();
          final a = await di.register<int>(Future.value(1));
          final b = await di.register<double>(Future.value(2.0));
          expect(
            1,
            a,
          );
          expect(
            2.0,
            b,
          );
          expect(
            2,
            di.registry.getGroup(groupEntity: di.focusGroup).length,
          );
          expect(
            1,
            await di.getOrNull<int>(),
          );
          expect(
            2.0,
            await di.getOrNull<double>(),
          );
          expect(
            2,
            di.registry.getGroup(groupEntity: di.focusGroup).length,
          );
          di.unregister<int>();
          di.unregister<double>();
          expect(
            0,
            di.registry.getGroup(groupEntity: di.focusGroup).length,
          );
        },
      );
    },
  );*/
}

// Source: ./tests/children.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';
// import 'package:df_di/src/_common.dart';

// import 'package:test/test.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  test(
    'Testing the registration of a DI instance (child), getting it and unregistering it.',
    () async {
      final di = DI();
      final child = DI();
      di.register(child);
      expect(child, di.getUnsafe<DI>());
      expect(child, di.getUnsafeT(DI));
      expect(di.isRegistered<DI>(), true);
      expect(di.isRegisteredT(DI), true);
      di.unregister<DI>();
      expect(di.isRegistered<DI>(), false);
      expect(di.isRegisteredT(DI), false);
    },
  );
  test(
    'Testing the lazy registration of a DI instance (child), getting it and unregistering it.',
    () {
      final di = DI();
      final child = DI();
      di.registerLazy<DI>(() => Sync.value(Ok(child)));
      expect(child, di.getLazySingletonUnsafe<DI>());
      expect(child, di.getLazySingletonUnsafeT(DI));
      expect(true, di.isRegistered<DI>());
      di.unregister<DI>();
      expect(false, di.isRegistered<DI>());
    },
  );
  test('Testing children of children.', () async {
    final c1 = DI();
    c1.register<int>(1);
    final c4 = c1.child().child().child().child();
    expect(1, c4.getUnsafe<int>());
    expect(true, c4.isRegistered<int>());
    c1.unregister<int>();
    expect(false, c4.isRegistered<int>());
  });
}

// Source: ./tests/runtime_type.dart
// //.title
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //
// // Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// // source code is governed by an MIT-style license described in the LICENSE
// // file located in this project's root directory.
// //
// // See: https://opensource.org/license/mit
// //
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //.title~

// import 'dart:async';

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// void main() {
//   group(
//     'Group 1',
//     () {
//       test(
//         'Test 1',
//         () async {
//           final di = DI.global;
//           di.register(1);
//           di.register('2');
//           expect(1, di.getOrNullT(int));
//           expect('2', di.getOrNullT(String));
//           di.unregisterT(int);
//           expect(null, di.getOrNullT(int));
//           Future.delayed(const Duration(seconds: 1), () => di.register(3));
//           expect(3, await di.untilT(int));
//         },
//       );
//     },
//   );
// }

// Source: ./tests/registry_tests.dart
// //.title
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //
// // Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// // source code is governed by an MIT-style license described in the LICENSE
// // file located in this project's root directory.
// //
// // See: https://opensource.org/license/mit
// //
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //.title~

//

// import 'package:df_di/df_di.dart';
// import 'package:df_di/src/core/di/_dependency.dart';
// import 'package:df_di/src/core/di/_di_registry.dart';

// import 'package:test/test.dart';

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// void main() {
//   group(
//     'Testing groups',
//     () {
//       test(
//         '- Testing groups state and clear',
//         () {
//           final registry = DIRegistry(
//             onChange: () {
//               print('CHANGED!!!');
//             },
//           );
//           registry.setDependency(Dependency<int>(1));
//           expect(
//             1,
//             registry.groupEntities.length,
//           );
//           expect(
//             "{null: {${TypeEntity(int).id}: Instance of 'Dependency<int>'}}",
//             registry.state.toString(),
//           );
//           registry.removeGroup();
//           expect(
//             0,
//             registry.groupEntities.length,
//           );
//           expect(
//             '{}',
//             registry.state.toString(),
//           );
//           registry.setGroup(
//             {TypeEntity(int): Dependency<int>(1)},
//             groupEntity: DefaultEntities.DEFAULT_GROUP.entity,
//           );
//           expect(
//             1,
//             registry.groupEntities.length,
//           );
//           expect(
//             "{${TypeEntity(int).id}: Instance of 'Dependency<int>'}",
//             registry.getGroup(groupEntity: DefaultEntities.DEFAULT_GROUP.entity).toString(),
//           );
//           registry.clear();
//           expect(
//             '{}',
//             registry.getGroup().toString(),
//           );
//           expect(
//             '{}',
//             registry.state.toString(),
//           );
//         },
//       );
//     },
//   );

//   group(
//     'Testing basics',
//     () {
//       test(
//         '- Testing basics with int',
//         () {
//           final registry = DIRegistry();
//           final dependency = Dependency<int>(1);
//           registry.setDependency(dependency);
//           expect(
//             dependency,
//             registry.getDependencyOrNull<int>(),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullT(int),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullK(TypeEntity(int)),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullK(TypeEntity(' i n t ')),
//           );
//           expect(
//             dependency,
//             registry.dependencies.where((test) => test.typeEntity == TypeEntity(int)).firstOrNull,
//           );
//           expect(
//             dependency,
//             registry.dependencies.where((test) => test.value.runtimeType == int).firstOrNull,
//           );
//           expect(
//             dependency,
//             registry.dependencies.where((test) => test.value is int).firstOrNull,
//           );
//           expect(
//             true,
//             registry.containsDependency<int>(),
//           );
//           expect(
//             true,
//             registry.containsDependencyT(int),
//           );
//           expect(
//             true,
//             registry.containsDependencyK(TypeEntity(int)),
//           );
//         },
//       );
//       test(
//         '- Testing basics with Future<int>',
//         () {
//           final registry = DIRegistry();
//           final dependency = Dependency<Future<int>>(Future.value(1));
//           registry.setDependency(dependency);
//           expect(
//             dependency,
//             registry.getDependencyOrNull<Future<int>>(),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullT(Future<int>),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullK(TypeEntity(Future, [int])),
//           );
//           expect(
//             dependency,
//             registry.getDependencyOrNullK(TypeEntity(' F u t u r e < i n t > ')),
//           );
//           expect(
//             dependency,
//             registry.dependencies
//                 .where((test) => test.typeEntity == TypeEntity(Future, [int]))
//                 .firstOrNull,
//           );
//           expect(
//             dependency,
//             registry.dependencies.where((test) {
//               return test.value.runtimeType.toString() == (Future<int>).toString();
//             }).firstOrNull,
//           );
//           expect(
//             dependency,
//             registry.dependencies.where((test) => test.value is Future<int>).firstOrNull,
//           );
//           expect(
//             true,
//             registry.containsDependency<Future<int>>(),
//           );
//           expect(
//             true,
//             registry.containsDependencyT(Future<int>),
//           );
//           expect(
//             true,
//             registry.containsDependencyK(TypeEntity(Future<int>)),
//           );
//         },
//       );
//     },
//   );
// }

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/b1.dart
// import 'package:df_di/df_di.dart';
// import 'package:get_it/get_it.dart';

// import 'run_benchmark_comparison.dart';

Future<void> b1() async {
  GetIt.instance.registerSingleton<Map<int, String>>({1: 'some data'});
  DI.root.register<Map<int, String>>({1: 'some data'});
  var lengthA = 0;
  var lengthB = 0;
  await runBenchmarkComparison(
    'Comparing: Getting a registered value.',
    getIt: () {
      final a = GetIt.instance.get<Map<int, String>>();
      final b = a.length;
      lengthA += b;
    },
    di: () {
      final a = DI.root.getSyncUnsafe<Map<int, String>>();
      final b = a.length;
      lengthB += b;
    },
  );
  print(lengthA);
  print(lengthB);
}

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/b3.dart
// import 'package:df_di/df_di.dart';
// import 'package:get_it/get_it.dart';

// import 'run_benchmark_comparison.dart';

Future<void> b3() async {
  final container1 = GetIt.asNewInstance();
  container1.registerSingleton<Map<int, String>>({1: 'some data'});
  final container2 = DI();
  container2.register<Map<int, String>>({1: 'some data'});
  await runBenchmarkComparison(
    'Comparing - isRegistered',
    getIt: () {
      container1.isRegistered<Map<int, String>>();
      container1.isRegistered<int>();
    },
    di: () {
      container2.isRegistered<Map<int, String>>();
      container1.isRegistered<int>();
    },
  );
}

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/b2.dart
// import 'package:df_di/df_di.dart';
// import 'package:get_it/get_it.dart';

// import 'run_benchmark_comparison.dart';

Future<void> b2() async {
  await runBenchmarkComparison(
    'Comparing: Registering value.',
    getIt: () {
      final container1 = GetIt.asNewInstance();
      container1.registerSingleton<Map<int, String>>({1: 'some data'});
    },
    di: () {
      final container2 = DI();
      container2.register<Map<int, String>>({1: 'some data'});
    },
  );
}

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/run_benchmark_comparison.dart
// import 'dart:async';

// import 'dart:math';

Future<void> runBenchmarkComparison(
  String name, {
  required FutureOr<void> Function() getIt,
  required FutureOr<void> Function() di,
  int runs = 100000,
  int iterations = 10,
}) async {
  final random = Random();
  final buffer = StringBuffer();

  buffer.writeln('Comparing: $name');
  var getItTimes = <int>[];
  var DITimes = <int>[];

  for (var i = 0; i < iterations; i++) {
    // Randomize test order.
    final order = random.nextBool();

    if (order) {
      getItTimes.add(await _measureTime('get_it', getIt, runs));
      DITimes.add(await _measureTime('df_di', di, runs));
    } else {
      DITimes.add(await _measureTime('df_di', di, runs));
      getItTimes.add(await _measureTime('get_it', getIt, runs));
    }

    // Allow time for GC or other system recovery.
    await Future<dynamic>.delayed(const Duration(milliseconds: 100));
  }

  // Calculate averages.
  final avgGetIt = getItTimes.reduce((a, b) => a + b) ~/ iterations;
  final avgDI = DITimes.reduce((a, b) => a + b) ~/ iterations;

  buffer.writeln('Average Times:');
  buffer.writeln('get_it: ${avgGetIt}ms');
  buffer.writeln('df_di: ${avgDI}ms');

  // Determine winner.
  final isGetItFaster = avgGetIt < avgDI;
  final slowerTime = isGetItFaster ? avgDI : avgGetIt;
  final fasterTime = isGetItFaster ? avgGetIt : avgDI;
  final percentageImprovement = ((slowerTime - fasterTime) / slowerTime * 100)
      .round();

  final winner =
      '${isGetItFaster ? 'get_it' : 'df_di'} at $percentageImprovement% faster with $runs runs';
  buffer.writeln('Winner: $winner');

  print(buffer.toString());
}

Future<int> _measureTime(
  String label,
  FutureOr<void> Function() testFunction,
  int runs,
) async {
  final ta = DateTime.now();
  for (var n = 0; n < runs; n++) {
    await testFunction();
  }
  final elapsed = DateTime.now().difference(ta).inMilliseconds;
  return elapsed;
}

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/b5.dart
// import 'package:df_di/df_di.dart';
// import 'package:get_it/get_it.dart';

// import 'run_benchmark_comparison.dart';

Future<void> b5() async {
  await runBenchmarkComparison(
    'Comparing - register then get lazy singletons',
    getIt: () {
      final container1 = GetIt.asNewInstance();
      container1.registerLazySingleton<Map<int, String>>(
        () => {1: 'some data'},
      );
      container1.get<Map<int, String>>();
    },
    di: () {
      final container2 = DI();
      container2.registerLazy<Map<int, String>>(
        () => SyncOk.value({1: 'some data'}),
      );
      container2.getLazySingleton<Map<int, String>>();
    },
  );
}

// Source: ./tests/di_vs_get_it_speed_test/lib/comparisons/b4.dart
// import 'package:df_di/df_di.dart';
// import 'package:get_it/get_it.dart';

// import 'run_benchmark_comparison.dart';

Future<void> b4() async {
  final container1 = GetIt.asNewInstance();
  container1.registerLazySingleton<Map<int, String>>(() => {1: 'some data'});
  final container2 = DI();
  container2.registerLazy<Map<int, String>>(
    () => SyncOk.value({1: 'some data'}),
  );
  await runBenchmarkComparison(
    'Comparing - get lazy singletons',
    getIt: () {
      container1.get<Map<int, String>>();
    },
    di: () {
      container2.getLazySingleton<Map<int, String>>();
    },
  );
}

// Source: ./tests/di_vs_get_it_speed_test/lib/main.dart
// import 'comparisons/b1.dart';
// import 'comparisons/b2.dart';
// import 'comparisons/b3.dart';
// import 'comparisons/b4.dart';
// import 'comparisons/b5.dart';

void main() async {
  await b1();
  await b2();
  await b3();
  await b4();
  await b5();
  // GetIt seems to have a slight but neglible edge when it comes to registering
  // dependencies, while DI has a slight but neglible edge when it comes to
  // getting dependencies.
  //
  // Speed is more important when getting dependencies than when registering
  // dependencies.
}

// Source: ./tests/service.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  test('Testing the registration and initialization of a service.', () async {
    final di = DI();
    final service = TestService();
    await di.registerLazy<TestService>(() => SyncOk.value(service)).value;
    print('Just registered...');
    final value1 = await di.getLazySingletonUnsafe<TestService>();
    final value2 = await di.getLazySingletonUnsafe<TestService>();
    expect(value1, service);
    expect(value1, value2);
  });
}

base class TestService extends Service {
  @override
  provideInitListeners() {
    return [
      ...super.provideInitListeners(),
      (_) {
        print('Initializing TestService!!!');
      },
    ];
  }
}

// Source: ./tests/stream_service.dart
// //.title
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //
// // Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// // source code is governed by an MIT-style license described in the LICENSE
// // file located in this project's root directory.
// //
// // See: https://opensource.org/license/mit
// //
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //.title~

// import 'dart:async';

// import 'package:df_di/df_di.dart';

// // import 'package:test/test.dart';

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// void main() async {
//   DI.session.registerLazyService(UserStreamingService.new);
//   print(await DI.session.getServiceSingleton<UserStreamingService>());
//   await Future.delayed(
//     const Duration(seconds: 3),
//     () => DI.session.unregister<UserStreamingService>(),
//   );

//   // group(
//   //   '1',
//   //   () {
//   //     test('- 1', () async {
//   //       DI.session.registerService(UserStreamingService.new);
//   //     });
//   //   },
//   // );
// }

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// final class UserStreamingService extends StreamService<Map<String, dynamic>, Object?> {
//   UserStreamingService();

//   @override
//   ServiceListeners<Object?> provideInitListeners() {
//     return [
//       ...super.provideInitListeners(),
//       (_) => super.initialData,
//     ];
//   }

//   @override
//   Stream<Map<String, dynamic>> provideInputStream(_) {
//     return StreamUtility.i.newPoller<Map<String, dynamic>>(
//       () async {
//         return {'id': 'pu_1s3hs64kshs74bms'};
//       },
//       const Duration(seconds: 1),
//     );
//   }

//   @override
//   // ignore: invalid_override_of_non_virtual_member
//   FutureOr<void> dispose() async {
//     await super.dispose();
//     print('Done!');
//   }

//   @override
//   ServiceListeners<Map<String, dynamic>> provideOnPushToStreamListeners() {
//     return [
//       ...super.provideOnPushToStreamListeners(),
//       (data) => print(data),
//     ];
//   }
// }

// Source: ./tests/stream_service_test/lib/main.dart
//

// import 'package:df_di/df_di.dart';
// import 'package:flutter/material.dart';

// void main() {
//   runApp(const MyApp());
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return const MaterialApp(
//       home: TestPage(),
//     );
//   }
// }

// class TestPage extends StatefulWidget {
//   const TestPage({super.key});

//   @override
//   State<TestPage> createState() => HestPageState();
// }

// class HestPageState extends State<TestPage> {
//   late CountingService countingService;

//   @override
//   void initState() {
//     super.initState();
//     countingService = CountingService();
//     countingService.init(60);
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       body: Center(
//         child: Column(
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: [
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.disposed) {
//                   countingService.dispose();
//                 }
//                 setState(() {
//                   countingService = CountingService();
//                 });
//                 countingService.init(60);
//               },
//               child: const Text('New Service'),
//             ),
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.initialized) {
//                   print('Cannot restart a service that has not been initialized.');
//                   return;
//                 }

//                 if (countingService.disposed) {
//                   print('Cannot restart a disposed service.');
//                   return;
//                 }

//                 countingService.restartService(60);
//               },
//               child: const Text('Restart Service'),
//             ),
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.disposed) {
//                   countingService.dispose();
//                 }
//               },
//               child: const Text('Dispose Service'),
//             ),
//             ValueListenableBuilder(
//               valueListenable: countingService.pValue,
//               builder: (context, value, child) {
//                 return Text('$value');
//               },
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }

// class CountingService extends StreamService<int, int> {
//   final pValue = ValueNotifier(0);
//   @override
//   ServiceListeners<int> provideInitListeners() {
//     return [
//       ...super.provideInitListeners(),
//       (data) => print('Initialized with data: $data'),
//     ];
//   }

//   @override
//   ServiceListeners<void> provideDisposeListeners() {
//     return [
//       ...super.provideDisposeListeners(),
//       (_) => print('Disposed!'),
//     ];
//   }

//   @override
//   Stream<int> provideInputStream(int params) async* {
//     var counter = 0;
//     while (counter <= params) {
//       await Future<void>.delayed(const Duration(milliseconds: 100));
//       yield counter++;
//     }
//   }

//   @override
//   ServiceListeners<int> provideOnPushToStreamListeners() {
//     return [
//       ...super.provideOnPushToStreamListeners(),
//       (data) => print('[CountingService]: $data'),
//       (data) => pValue.value = data,
//     ];
//   }
// }

// Source: ./tests/stream_service_test/.dart_tool/dartpad/web_plugin_registrant.dart
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// ignore_for_file: type=lint

void registerPlugins() {}

// Source: ./tests/unregister.dart
// //.title
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //
// // Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// // source code is governed by an MIT-style license described in the LICENSE
// // file located in this project's root directory.
// //
// // See: https://opensource.org/license/mit
// //
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //.title~

//

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// void main() {
//   group(
//     'Testing unregister',
//     () {
//       test(
//         '- Unregistering completed futures',
//         () async {
//           final di = DI();
//           final a = await di.register<int>(
//             Future.value(1),
//             onUnregister: (e) {
//               print('Unregistering $e');
//             },
//           );
//           final b = await di.register<double>(
//             Future.value(2.0),
//             onUnregister: (e) {
//               print('Unregistering $e');
//             },
//           );
//           expect(
//             1,
//             a,
//           );
//           expect(
//             2.0,
//             b,
//           );
//           expect(
//             2,
//             di.registry.getGroup(groupEntity: di.focusGroup).length,
//           );
//           expect(
//             1,
//             await di.getOrNull<int>(),
//           );
//           expect(
//             2.0,
//             await di.getOrNull<double>(),
//           );
//           expect(
//             2,
//             di.registry.getGroup(groupEntity: di.focusGroup).length,
//           );
//           di.unregister<int>();
//           di.unregister<double>();
//           expect(
//             0,
//             di.registry.getGroup(groupEntity: di.focusGroup).length,
//           );
//         },
//       );
//       test(
//         '- Unregistering uncompleted futures',
//         () async {
//           final di = DI();
//           di.register<int>(
//             Future.value(1),
//             onUnregister: (e) {
//               print('Unregistering $e');
//             },
//           );
//           di.getOrNull<int>();
//           di.unregister<int>();
//         },
//       );
//       test(
//         '- Unregistering all',
//         () async {
//           final di = DI();
//           di.register<int>(1, groupEntity: const Entity(1));
//           di.register<int>(2, groupEntity: const Entity(2));
//           di.register<int>(3, groupEntity: const Entity(3));
//           di.register<int>(4, groupEntity: const Entity(4));
//           // final values = di.unregisterAll().thenOr((e) => e.map((e) => e.value).toList());
//           // expect(
//           //   '[4, 3, 2, 1]',
//           //   values.toString(),
//           // );
//         },
//       );
//     },
//   );
// }

// Source: ./tests/test_services_1.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_di/df_di.dart';

// import 'package:test/test.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main() {
  test('Testing the registration and initialization of a service.', () async {
    final di = DI();

    () async {
      di.register<TestService>(() async {
        final service = TestService();
        service.init(const None());
        return service;
      }());
    }();

    print(await di.untilSuper<TestService>().value);
  });
}

base class TestService extends Service {
  @override
  provideInitListeners() {
    return [
      ...super.provideInitListeners(),
      (_) async {
        return Future.delayed(const Duration(seconds: 1), () => print('Done!'));
      },
    ];
  }
}

// Source: ./tests/basic_service_test/lib/main.dart
//

// import 'package:df_di/df_di.dart';
// import 'package:flutter/material.dart';

// void main() {
//   runApp(const MyApp());
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return const MaterialApp(
//       home: TestPage(),
//     );
//   }
// }

// class TestPage extends StatefulWidget {
//   const TestPage({super.key});

//   @override
//   State<TestPage> createState() => HestPageState();
// }

// class HestPageState extends State<TestPage> {
//   late CountingService countingService;
//   int counter = 0;

//   @override
//   void initState() {
//     super.initState();
//     countingService = CountingService();
//     countingService.init(counter);
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       body: Center(
//         child: Column(
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: [
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.disposed) {
//                   countingService.dispose();
//                 }
//                 countingService = CountingService();
//                 countingService.init(++counter);
//               },
//               child: const Text('New Service'),
//             ),
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.initialized) {
//                   print('Cannot restart a service that has not been initialized.');
//                   return;
//                 }

//                 if (countingService.disposed) {
//                   print('Cannot restart a disposed service.');
//                   return;
//                 }

//                 countingService.restartService(++counter);
//               },
//               child: const Text('Restart Service'),
//             ),
//             FilledButton(
//               onPressed: () {
//                 if (!countingService.disposed) {
//                   countingService.dispose();
//                 }
//               },
//               child: const Text('Dispose Service'),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }

// class CountingService extends Service<int> {
//   @override
//   ServiceListeners<int> provideInitListeners() {
//     return [
//       ...super.provideInitListeners(),
//       (data) => print('Initialized with data: $data'),
//     ];
//   }

//   @override
//   ServiceListeners<void> provideDisposeListeners() {
//     return [
//       ...super.provideDisposeListeners(),
//       (_) => print('Disposed!'),
//     ];
//   }
// }

// Source: ./tests/basic_service_test/.dart_tool/dartpad/web_plugin_registrant.dart
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// ignore_for_file: type=lint

void registerPlugins() {}

// Source: ./dart_consolidate.dart
// import 'dart:io';

void main(List<String> arguments) async {
  final sourceDirPath = arguments.firstOrNull ?? '.';
  final sourceDir = Directory(sourceDirPath);

  if (!await sourceDir.exists()) {
    print('Directory does not exist: $sourceDirPath');
    return;
  }

  final outputFile = File('consolidated_output.dart.txt');
  final sink = outputFile.openWrite();
  final imports = <String>{}; // Set to store unique non-local imports

  // Process all files and collect imports
  await _processDirectory(sourceDir, sink, imports);

  // Write imports at the top
  sink.writeln('// Consolidated Imports');
  for (var import in imports) {
    sink.writeln(import);
  }
  sink.writeln();

  // Reprocess files to write their content with commented imports and part directives
  await _writeFileContents(sourceDir, sink);

  await sink.flush();
  await sink.close();
  print('Consolidation complete. Output written to ${outputFile.path}');
}

Future<void> _processDirectory(
  Directory dir,
  IOSink sink,
  Set<String> imports,
) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _collectImports(entity, imports);
    }
  }
}

Future<void> _collectImports(File file, Set<String> imports) async {
  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    if (trimmedLine.startsWith('import ')) {
      if (trimmedLine.startsWith("import 'package:") ||
          trimmedLine.startsWith("import 'dart:")) {
        imports.add(line); // Store non-local imports
      }
    }
  }
}

Future<void> _writeFileContents(Directory dir, IOSink sink) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _processFile(entity, sink);
    }
  }
}

Future<void> _processFile(File file, IOSink sink) async {
  // Write comment with original file path
  sink.writeln('// Source: ${file.path}');

  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    // Comment out import statements and part directives
    if (trimmedLine.startsWith('import ') ||
        trimmedLine.startsWith('part ') ||
        trimmedLine.startsWith('part of ')) {
      sink.writeln('// $line');
    } else {
      sink.writeln(line);
    }
  }
  // Add a newline after each file's content
  sink.writeln();
}

// Source: ./flutter_example/lib/main.dart
// import 'package:flutter/material.dart';
// import 'package:df_di/df_di.dart';

// Here we test if we can successfully get a registered value using getT when
// the app is compiled with WASM and minification via "flutte run -d --wasm --release".
void main() {
  DI.global.register<List<int>>([42]);
  final answer = DI.global.getT(List<int>).unwrap().unwrap();
  final output = '${List<int>}: $answer';

  print(output);
  // Running with WASM, release, and optimization level 4:
  // flutter build web --wasm --release --optimization-level 4
  // dart pub global activate dhttpd
  // dhttpd --path build/web --port 8080
  // KILLING:
  // lsof -i :8080
  // kill -9 <PID>
  final isObfuscated = 'List<int>' != '${List<int>}';
  print('Is obfuscated: $isObfuscated');
  testObfuscationIssue();
  runApp(MaterialApp(home: Scaffold(body: Text(output))));
}

void testObfuscationIssue() {
  // Prints true true
  {
    final a = TypeEntity(Map<String, dynamic>);
    final b = TypeEntity(Map, [String, dynamic]);
    print(a == b);
    final c = TypeEntity(TypeEntity(Map), [String, dynamic]);
    print(a == c);
  }
  // Prints true true
  {
    print(dynamic);
    final a = TypeEntity('${Map<String, dynamic>}');
    final b = TypeEntity('$Map', ['$String', '$dynamic']);
    print(a == b);
    final c = TypeEntity(TypeEntity(Map), ['$String', 'dynamic']);
    print(a == c);
  }
}

// Source: ./flutter_example/.dart_tool/dartpad/web_plugin_registrant.dart
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// ignore_for_file: type=lint

void registerPlugins() {}

// Source: ./.github/scripts/update_changelog.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  final version = args.isNotEmpty ? args[0] : '0.1.0';
  final comitMesssage = args.length > 1 ? args[1].replaceFirst('+', '') : '';
  final changelogPath = 'CHANGELOG.md';
  final file = File(changelogPath);
  if (!file.existsSync()) {
    print('$changelogPath does not exist.');
    exit(1);
  }
  var contents = file.readAsStringSync();
  contents = contents.replaceAll('# Changelog', '').trim();
  final sections = extractSections(contents);
  final versionExist = sections.where((e) => e.version == version).isNotEmpty;
  if (versionExist) {
    sections.where((e) => e.version == version).forEach((e) {
      e.addUpdate(comitMesssage);
    });
  } else {
    sections.add(
      _VersionSection(
        version: version,
        releasedAt: DateTime.now().toUtc(),
        updates: {comitMesssage},
      ),
    );
  }
  contents = '# Changelog\n\n${(sections.toList()..sort((a, b) {
      return compareVersions(b.version, a.version);
    })).map((e) => e.toString()).join('\n')}';

  file.writeAsStringSync(contents);
  print('Changelog updated with version $version.');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Set<_VersionSection> extractSections(String contents) {
  final headerPattern = RegExp(r'## \[\d+\.\d+\.\d+(\+\d+)?\]');
  final allVersionMatches = headerPattern.allMatches(contents).toList();
  final results = <_VersionSection>{};
  for (var i = 0; i < allVersionMatches.length; i++) {
    final start = allVersionMatches[i].end;
    final end = i + 1 < allVersionMatches.length ? allVersionMatches[i + 1].start : contents.length;
    final sectionContents = contents.substring(start, end).trim();
    final lines = sectionContents.split('\n').where((line) => line.isNotEmpty).toList();
    final version =
        allVersionMatches[i].group(0)!.substring(4, allVersionMatches[i].group(0)!.length - 1);
    var releasedAt = DateTime.now().toUtc();
    final updates = <String>{};
    final old = lines
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .map((e) => e.startsWith('-') ? e.substring(1) : e)
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty);
    for (var line in old) {
      if (line.contains('Released @')) {
        releasedAt = parseReleaseDate(line);
      } else {
        updates.add(line);
      }
    }
    results.add(
      _VersionSection(
        version: version,
        releasedAt: releasedAt,
        updates: updates,
      ),
    );
  }

  return results;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _VersionSection {
  //
  //
  //

  String version;
  DateTime releasedAt;
  Set<String> updates;

  //
  //
  //

  _VersionSection({
    required this.version,
    required this.releasedAt,
    this.updates = const {},
  });

  //
  //
  //

  void addUpdate(String update) {
    updates.add(update);
    releasedAt = DateTime.now().toUtc();
  }

  //
  //
  //

  @override
  String toString() {
    final updatesString = updates.map((update) => '- $update').join('\n');
    return '## [$version]\n\n- Released @ ${releasedAt.month}/${releasedAt.year} (UTC)\n$updatesString\n';
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

int compareVersions(String version1, String version2) {
  List<int> parseVersion(String version) {
    // Split by the '+' first to handle the build number
    final parts = version.split('+');
    final versionParts = parts[0].split('.').map(int.tryParse).map((e) => e ?? 0).toList();
    // Add the build number as the last part (if it exists)
    if (parts.length > 1) {
      versionParts.add(int.tryParse(parts[1]) ?? 0);
    }
    return versionParts;
  }

  final v1 = parseVersion(version1);
  final v2 = parseVersion(version2);
  final maxLength = v1.length > v2.length ? v1.length : v2.length;
  for (var i = 0; i < maxLength; i++) {
    final part1 = i < v1.length ? v1[i] : 0;
    final part2 = i < v2.length ? v2[i] : 0;
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  return 0;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

DateTime parseReleaseDate(String line) {
  if (line.contains('Released @')) {
    final temp = line.split('Released @').last.trim().replaceAll(' (UTC)', '');
    final parts = temp.split('/');
    if (parts.length == 2) {
      final month = int.tryParse(parts[0]) ?? 1;
      final year = int.tryParse(parts[1]) ?? DateTime.now().year;
      return DateTime.utc(year, month);
    }
  }

  return DateTime.now().toUtc();
}

// Source: ./lib/df_di.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A pragmatic dependency injection (DI) system, coupled with service classes for seamless state management in Dart.
library;

export 'src/_src.g.dart';

export 'package:df_type/df_type.dart';
export 'package:df_safer_dart/df_safer_dart.dart';

// Source: ./lib/src/core/di/_dependency.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents a dependency stored within [DIRegistry]. Dependencies are wrappers
/// around values with additional [DependencyMetadata] to manage their
/// lifecycle.
@internal
final class Dependency<T extends Object> {
  Resolvable<T> _value;

  Dependency(this._value, {this.metadata = const None()}) {
    if (this.metadata.isSome()) {
      final a = this.metadata.unwrap();
      if (a._initialType.isSome()) {
        a._initialType = Some(_value.runtimeType);
      }
    }
  }

  Dependency._internal(this._value, {required this.metadata});

  /// The value contained within this [Dependency].
  Resolvable<T> get value => _value;

  Async<T>? _cachedValue;

  /// Caches the result of an asynchronous operation to prevent re-execution.
  @protected
  Async<T> cacheAsyncValue() {
    if (_cachedValue != null) {
      return _cachedValue!;
    }
    _cachedValue = Async(() async {
      final result = await _value.async().unwrap().value;
      _value = Sync.value(result);
      return result.unwrap();
    });
    return _cachedValue!;
  }

  /// The metadata associated with this [Dependency].
  final Option<DependencyMetadata> metadata;

  /// Returns the `preemptivetypeEntity` of [metadata] if not `null` or the
  /// runtime type key of [_value].
  Entity get typeEntity {
    final preemptivetypeEntity = metadata.unwrap().preemptivetypeEntity;
    if (preemptivetypeEntity.isDefault()) {
      return TypeEntity(_value.runtimeType);
    } else {
      return preemptivetypeEntity;
    }
  }

  /// Creates a new [Dependency] instance with a different value of type [R],
  /// while retaining the existing [metadata].
  Dependency<R> passNewValue<R extends Object>(Resolvable<R> newValue) {
    return Dependency<R>._internal(newValue, metadata: metadata);
  }

  /// Returns a new [Dependency] instance where the current [_value] is cast
  /// to type [R], while retaining the existing [metadata].
  Dependency<R> transf<R extends Object>() => passNewValue(_value.transf());

  /// Creates a new instance with updated fields, preserving the values of any
  /// fields not explicitly specified.
  Dependency<T> copyWith({
    Option<Resolvable<T>> value = const None(),
    Option<DependencyMetadata> metadata = const None(),
  }) {
    return Dependency<T>(
      value.isNone() ? this._value : value.unwrap(),
      metadata: metadata,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Dependency && hashCode == other.hashCode;
  }

  @override
  int get hashCode {
    return Object.hashAll([_value, metadata]);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Contains metadata for a [Dependency] to facilitate lifecycle management,
/// track registration details, and support dependency resolution.
@internal
class DependencyMetadata {
  DependencyMetadata({
    this.groupEntity = const DefaultEntity(),
    this.preemptivetypeEntity = const DefaultEntity(),
    this.index = const None(),
    this.onUnregister = const None(),
  });

  /// The type group to which the [Dependency] belongs. This enables
  /// dependencies of the same type to coexist in the DI container as long as
  /// they are assigned to different groups.
  final Entity groupEntity;

  /// The type key that the dependency is associated with within its group. If
  /// not `null`, it will override the default type key.
  final Entity preemptivetypeEntity;

  /// The type of [Dependency._value] at the time the [Dependency] was registered.
  /// This type remains unchanged even if [Dependency._value] is updated through
  /// [Dependency.passNewValue]. This property consistently reflects the original type
  /// with which the dependency was registered.
  Option<Type> get initialType => _initialType;
  Option<Type> _initialType = const None();

  /// The index at which this dependency was registered in the dependency
  /// injection container. This helps in tracking the order of registration
  /// and ensuring proper management of dependencies.
  final Option<int> index;

  /// A callback to be invoked when this dependency is unregistered.
  final Option<TOnUnregisterCallback<Object>> onUnregister;

  /// Creates a new instance with updated fields, preserving the values of any
  /// fields not explicitly specified.
  DependencyMetadata copyWith({
    Entity groupEntity = const DefaultEntity(),
    Entity preemptivetypeEntity = const DefaultEntity(),
    Option<Type> initialType = const None(),
    Option<int> index = const None(),
    Option<TOnUnregisterCallback<Object>> onUnregister = const None(),
  }) {
    return DependencyMetadata(
      groupEntity: groupEntity.isNotDefault() ? groupEntity : this.groupEntity,
      preemptivetypeEntity:
          preemptivetypeEntity.isNotDefault() ? preemptivetypeEntity : this.preemptivetypeEntity,
      index: index.isSome() ? index : this.index,
      onUnregister: onUnregister.isSome() ? onUnregister : this.onUnregister,
    ).._initialType = initialType.isSome() ? initialType : _initialType;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is DependencyMetadata && hashCode == other.hashCode;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      groupEntity,
      preemptivetypeEntity,
      index,
      onUnregister,
      _initialType,
    ]);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A typedef for a callback function to invoke when a dependency is
/// unregistered. The function passes the value of the unregistered dependency
/// in order to facilitate any necessary cleanup or additional processing
/// that might be required for the [value].
@internal
typedef TOnUnregisterCallback<T extends Object> = Resolvable<None>? Function(Result<T> value);

/// A typedef for a function that evaluates the validity of a dependency.
@internal
typedef TDependencyValidator<T extends Object> = bool Function(T value);

// Source: ./lib/src/core/di/di.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

final class DI extends DIBase
    with
        SupportsMixinK,
        SupportsMixinT,
        SupportsConstructorsMixin,
        SupportsConstructorsMixinK,
        SupportsConstructorsMixinT,
        SupportsChildrenMixin,
        SupportsUnregisterAll {
  DI();

  /// A predefined container recommended for application-wide dependencies.
  /// This container serves as the parent for other containers.
  static final root = DI();

  /// A predefined container recommended for global dependencies. This
  /// container is a child of [root].
  @pragma('vm:prefer-inline')
  static DI get global => root.child(groupEntity: const GlobalEntity());

  /// A predefined container recommended for session-specific dependencies.
  /// This container is a child of [global].
  @pragma('vm:prefer-inline')
  static DI get session => global.child(groupEntity: const SessionEntity());

  /// A predefined container recommended for user-specific dependencies.
  /// This container is a child of [session].
  @pragma('vm:prefer-inline')
  static DI get user => session.child(groupEntity: const UserEntity());

  /// A predefined container recommended for theme-related objects.
  /// This container is a child of [root].
  @pragma('vm:prefer-inline')
  static DI get theme => root.child(groupEntity: const ThemeEntity());

  /// A predefined container recommended for objects intended for development
  /// environments. This container is a child of [root].
  @pragma('vm:prefer-inline')
  static DI get dev => root.child(groupEntity: const DevEntity());

  /// A predefined container recommended for objects intended for production
  /// environments. This container is a child of [root].
  @pragma('vm:prefer-inline')
  static DI get prod => root.child(groupEntity: const ProdEntity());

  /// A predefined container recommended for objects intended for testing
  /// environments. This container is a child of [root].
  @pragma('vm:prefer-inline')
  static DI get test => root.child(groupEntity: const TestEntity());
}

// Source: ./lib/src/core/di/_di_registry.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Registry for storing and managing dependencies by runtime type and a group
/// entity.
final class DIRegistry {
  //
  //
  //

  DIRegistry({this.onChange = const None()});

  /// Represents the internal state of this [DIRegistry] instance, stored as a
  /// map.
  final TRegistryState _state = {};

  /// A callback invoked whenever the [state] is updated.
  final Option<TOnChangeRegistry> onChange;

  /// A snapshot describing the current state of the dependencies.
  @pragma('vm:prefer-inline')
  TRegistryState get state => TRegistryState.unmodifiable(
        _state,
      ).map((k, v) => MapEntry(k, Map.unmodifiable(v)));

  /// Returns an iterable of all dependencies in the registry, unsorted.
  @protected
  @pragma('vm:prefer-inline')
  Iterable<Dependency> get unsortedDependencies => _state.entries.expand((e) => e.value.values);

  /// Returns a list of all dependencies, sorted in reverse order of registration (newest first).
  /// Dependencies without a registration index are placed at the end.
  List<Dependency> get reversedDependencies {
    final entries = _state.entries.expand((e) => e.value.values);
    final sortedEntries = entries.map((d) {
      final metadata = d.metadata;
      final index = metadata.isSome() && metadata.unwrap().index.isSome()
          ? metadata.unwrap().index.unwrap()
          : -1;
      return (index, d);
    }).toList();
    sortedEntries.sort((a, b) => b.$1.compareTo(a.$1));
    return List.unmodifiable(sortedEntries.map((e) => e.$2));
  }

  /// Returns all dependencies witin this [DIRegistry] instance of type
  /// [T].
  @pragma('vm:prefer-inline')
  Iterable<Dependency> dependenciesWhereType<T extends Object>() {
    return reversedDependencies.map((e) => e.value is T ? e : null).nonNulls;
  }

  /// Returns all dependencies witin this [DIRegistry] instance of type [type].
  /// Unlike [dependenciesWhereType], this will not include subtypes of [type].
  @pragma('vm:prefer-inline')
  Iterable<Dependency> dependenciesWhereTypeT(Type type) {
    return dependenciesWhereTypeK(TypeEntity(type));
  }

  /// Returns all dependencies witin this [DIRegistry] instance of type
  /// [typeEntity]. Unlike [dependenciesWhereType], this will not include
  /// subtypes.
  @pragma('vm:prefer-inline')
  Iterable<Dependency> dependenciesWhereTypeK(Entity typeEntity) {
    return reversedDependencies.map((e) => e.typeEntity == typeEntity ? e : null).nonNulls;
  }

  /// A snapshot of the current group entities within [state].
  @pragma('vm:prefer-inline')
  List<Entity> get groupEntities => List.unmodifiable(_state.keys);

  /// Updates the [state] by setting or updating [dependency].
  @protected
  void setDependency(Dependency dependency) {
    final groupEntity = dependency.metadata.isSome()
        ? dependency.metadata.unwrap().groupEntity
        : const DefaultEntity();
    final typeEntity = dependency.typeEntity;
    final currentDep = Option.fromNullable(_state[groupEntity]?[typeEntity]);

    if (currentDep.isNone() || currentDep.unwrap() != dependency) {
      (_state[groupEntity] ??= {})[typeEntity] = dependency;
      onChange.ifSome((e) => e.unwrap()());
    }
  }

  /// Checks if any dependency of type [T] or subtypes exists under the
  /// specified [groupEntity]
  ///
  /// Returns `true` if it does and `false` if it doesn't.
  @pragma('vm:prefer-inline')
  bool containsDependency<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    return _state[groupEntity]?.values.any((e) => e.value is Resolvable<T>) == true;
  }

  /// Checks if any dependency with the exact [type] exists under the specified
  /// [groupEntity]. Unlike [containsDependency], this will not include subtypes
  /// of [type].
  ///
  /// Returns `true` if it does and `false` if it doesn't.
  @pragma('vm:prefer-inline')
  bool containsDependencyT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final a = TypeEntity(Sync, [type]);
    final b = TypeEntity(Async, [type]);
    return _state[groupEntity]?.values.any(
              (e) => e.typeEntity == a || e.typeEntity == b,
            ) ==
        true;
  }

  /// Checks if any dependency registered under the exact [typeEntity] exists
  /// under the specified [groupEntity]. Unlike [containsDependency], this will
  /// not include subtypes.
  ///
  /// Returns `true` if it does and `false` if it doesn't.
  @pragma('vm:prefer-inline')
  bool containsDependencyK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final a = TypeEntity(Sync, [typeEntity]);
    final b = TypeEntity(Async, [typeEntity]);
    return _state[groupEntity]?.values.any(
              (e) => e.typeEntity == a || e.typeEntity == b,
            ) ==
        true;
  }

  /// Returns any dependency of type [T] or subtypes under the specified
  /// [groupEntity].
  @pragma('vm:prefer-inline')
  Option<Dependency<T>> getDependency<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    return Option.fromNullable(
      _state[groupEntity]?.values.firstWhereOrNull((e) => e.value is Resolvable<T>)?.transf<T>(),
    );
  }

  /// Returns an iterable of all dependencies of type [T] within the specified [groupEntity].
  /// This method considers exact type matches, not subtypes.
  @pragma('vm:prefer-inline')
  Iterable<Dependency<T>> getDependencies<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    return _state[groupEntity]?.values.whereType<Dependency<T>>() ?? [];
  }

  /// Returns any dependency with the exact [type] under the specified
  /// [groupEntity]. Unlike [getDependency], this will not include subtypes.
  @protected
  @pragma('vm:prefer-inline')
  Option<Dependency> getDependencyT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    return getDependencyK(TypeEntity(type), groupEntity: groupEntity);
  }

  /// Returns any dependency with the exact [typeEntity] under the specified
  /// [groupEntity]. Unlike [getDependency], this will not include subtypes.
  @protected
  @pragma('vm:prefer-inline')
  Option<Dependency> getDependencyK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final a = TypeEntity(Sync, [typeEntity]);
    final b = TypeEntity(Async, [typeEntity]);
    return Option.fromNullable(
      _state[groupEntity]?.values.firstWhereOrNull(
            (e) => e.typeEntity == a || e.typeEntity == b,
          ),
    );
  }

  /// Removes the first dependency of type [T] (or its subtypes) found under the specified [groupEntity].
  /// If the group becomes empty after removal, the group itself is removed.
  @protected
  @pragma('vm:prefer-inline')
  Option<Dependency> removeDependencyT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    return removeDependencyK(TypeEntity(type), groupEntity: groupEntity);
  }

  /// Removes the first dependency of type [T] (or its subtypes) found under the specified [groupEntity].
  /// If the group becomes empty after removal, the group itself is removed.
  Option<Dependency<T>> removeDependency<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    final group = _state[groupEntity];
    if (group == null) {
      return const None();
    }
    final key = group.entries.firstWhereOrNull((e) => e.value.value is Resolvable<T>)?.key;
    if (key == null) {
      return const None();
    }
    final dependency = group.remove(key);
    if (dependency == null) {
      return const None();
    }
    if (group.isEmpty) {
      removeGroup(groupEntity: groupEntity);
    }
    onChange.ifSome((e) => e.unwrap()());
    return Some(dependency.transf());
  }

  /// Removes the dependency with the exact [typeEntity] under the specified [groupEntity].
  /// If the group becomes empty after removal, the group itself is removed.
  @protected
  Option<Dependency> removeDependencyK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final group = _state[groupEntity];
    if (group == null) {
      return const None();
    }
    Option<Dependency<Object>> removed;
    removed = Option.fromNullable(group.remove(TypeEntity(Sync, [typeEntity])));
    if (removed.isNone()) {
      removed = Option.fromNullable(
        group.remove(TypeEntity(Async, [typeEntity])),
      );
    }
    if (removed.isNone()) {
      return const None();
    }
    if (group.isEmpty) {
      removeGroup(groupEntity: groupEntity);
    }
    onChange.ifSome((e) => e.unwrap()());
    return removed.map((e) => e.transf());
  }

  /// Updates the [state] by setting or replacing the [group] under the
  /// specified [groupEntity].
  @protected
  void setGroup(
    TDependencyGroup<Object> group, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final currentGroup = _state[groupEntity];
    final equals = const MapEquality<Entity, Dependency>().equals(
      currentGroup,
      group,
    );
    if (!equals) {
      _state[groupEntity] = group;
      onChange.ifSome((e) => e.unwrap()());
    }
  }

  /// Gets the [TDependencyGroup] with the specified [groupEntity] from the [state]
  /// or `null` if none exist.
  @pragma('vm:prefer-inline')
  TDependencyGroup<Object> getGroup({
    Entity groupEntity = const DefaultEntity(),
  }) {
    return TDependencyGroup.unmodifiable(_state[groupEntity] ?? {});
  }

  @pragma('vm:prefer-inline')
  void removDependencyWhere(
    bool Function(Entity entity, Dependency dependency) test, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    _state[groupEntity]?.removeWhere(test);
  }

  /// Removes the [TDependencyGroup] with the specified [groupEntity] from the
  /// [state].
  @protected
  @pragma('vm:prefer-inline')
  void removeGroup({Entity groupEntity = const DefaultEntity()}) {
    _state.remove(groupEntity);
    onChange.ifSome((e) => e.unwrap()());
  }

  /// Clears the [state], resetting the registry and effectively restoring it
  /// to the state of a newly created [DIRegistry] instance.
  @pragma('vm:prefer-inline')
  void clear() {
    _state.clear();
    onChange.ifSome((e) => e.unwrap()());
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A typedef for a Map representing the state of a [DIRegistry].
typedef TRegistryState = Map<Entity, TDependencyGroup<Object>>;

/// A typedef for a Map representing a group of dependencies organized by a
/// group entity.
typedef TDependencyGroup<T extends Object> = Map<Entity, Dependency<T>>;

/// A typedef for a callback function to invoke when the `state` of a [DIRegistry]
/// changes.
typedef TOnChangeRegistry = void Function();

// Source: ./lib/src/core/di/_di_base.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '/src/_common.dart';
// import '/src/core/_reserved_safe_finisher.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Base class for the dependency injection container
base class DIBase {
  //
  //
  //

  /// Internal registry that stores dependencies.
  @protected
  final registry = DIRegistry();

  /// Parent containers.
  @protected
  final parents = <DI>{};

  /// A key that identifies the current group in focus for dependency management.
  Entity focusGroup = const DefaultEntity();

  @protected
  int _indexIncrementer = 0;

  /// Container for child DI instances.
  @protected
  Option<DI> childrenContainer = const None();

  /// Retrieves an iterable of child [DI] instances.
  @protected
  Option<Iterable<DI>> children() {
    return childrenContainer.map(
      (e) => e.registry.unsortedDependencies.map(
        (e) => e.transf<Lazy<DI>>().value.unwrapSync().unwrap().singleton.unwrapSync().unwrap(),
      ),
    );
  }

  //
  //
  //

  /// Registers a dependency with the container.
  Resolvable<T> register<T extends Object>(
    FutureOr<T> value, {
    FutureOr<void> Function(T value)? onRegister,
    TOnUnregisterCallback<T>? onUnregister,
    Entity groupEntity = const DefaultEntity(),
    bool enableUntilExactlyK = false,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final g = groupEntity.preferOverDefault(focusGroup);
    final metadata = DependencyMetadata(
      index: Some(_indexIncrementer++),
      groupEntity: g,
      onUnregister: onUnregister != null ? Some((e) => onUnregister(e.transf())) : const None(),
    );
    final a = Resolvable(
      () => consec(value, (e) => consec(onRegister?.call(e), (_) => e)),
    );
    final b = registerDependency<T>(
      dependency: Dependency(a, metadata: Some(metadata)),
      checkExisting: true,
    );
    if (b.isErr()) {
      return Sync.value(b.err().unwrap().transErr());
    }
    if (value is! ReservedSafeFinisher<T>) {
      // Used for until.
      // NOTE: CHANGED FROM T TO Object so that it attems to finish ANY ReservedSafeFinisher!
      _maybeFinish<Object>(value: value, g: g);

      // Used for untilT and untilK. Disabled by default to improve performance.
      if (enableUntilExactlyK) {
        (this as SupportsMixinK).maybeFinishK<T>(g: g);
      }
    }
    return a.map((e) {
      return b.unwrap().value;
    }).comb2();
  }

  /// Attempts to finish any pending [until] calls for the given type and group
  /// when a new dependency is registered.
  void _maybeFinish<T extends Object>({
    required FutureOr<Object> value, // General "Object"
    required Entity g,
  }) {
    for (final di in [this as DI, ...children().unwrapOr([])]) {
      // Get all finishers in group g.
      final finishers = di.registry.state[g]?.values
          .map((e) => e.value)
          .where((e) => e.isSync())
          .map((e) => e.unwrapSync().value)
          .where((e) => e.isOk())
          .map((e) => e.unwrap())
          // Get all finishers regardless of type.
          .whereType<ReservedSafeFinisher<T>>();
      if (finishers == null) continue;
      // Try each one to see if they can finish. It will only be able to finish
      // if value is compatible with the finisher.
      for (final finisher in finishers) {
        try {
          finisher.finish(value as FutureOr<T>);
          break;
        } catch (_) {
          // Skip finishers that throw. Either by incorrect type T or the
          // finisher can't complete the Future.
        }
      }
    }
  }

  /// Registers a [Dependency] object directly into the registry.
  @protected
  Result<Dependency<T>> registerDependency<T extends Object>({
    required Dependency<T> dependency,
    bool checkExisting = false,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final g = dependency.metadata.isSome() ? dependency.metadata.unwrap().groupEntity : focusGroup;
    if (checkExisting) {
      final option = getDependency<T>(groupEntity: g, traverse: false);
      if (option.isSome()) {
        return Err('Dependency already registered.');
      }
    }
    registry.setDependency(dependency);
    return Ok(dependency);
  }

  /// Unregisters a dependency from the container.
  Resolvable<None> unregister<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
    bool triggerOnUnregisterCallbacks = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    Resolvable<None>? result;
    final g = groupEntity.preferOverDefault(focusGroup);
    for (final di in [this as DI, ...parents]) {
      final dependencyOption = di.removeDependency<T>(groupEntity: g);
      if (dependencyOption.isNone()) {
        continue;
      }
      if (triggerOnUnregisterCallbacks) {
        final dependency = dependencyOption.unwrap();
        final metadataOption = dependency.metadata;
        if (metadataOption.isSome()) {
          final metadata = metadataOption.unwrap();
          final onUnregisterOption = metadata.onUnregister;
          if (onUnregisterOption.isSome()) {
            final onUnregister = onUnregisterOption.unwrap();
            result = dependency.value.map((e) => onUnregister(Ok(e))!).comb();
          }
        }
      }
      if (!removeAll) {
        break;
      }
    }
    return result ?? SyncOk.value(const None());
  }

  /// Removes a dependency from the internal registry.
  @protected
  @pragma('vm:prefer-inline')
  Option<Dependency> removeDependency<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final g = groupEntity.preferOverDefault(focusGroup);
    Option<Dependency> result;
    result = registry.removeDependency<T>(groupEntity: g);

    if (result.isNone()) {
      result = registry.removeDependency<Lazy<T>>(groupEntity: g);
    }
    return result;
  }

  /// Retrieves a synchronous dependency unsafely, returning the instance
  /// directly or throwing an error if not found or async.
  bool isRegistered<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final g = groupEntity.preferOverDefault(focusGroup);
    if (registry.containsDependency<T>(groupEntity: g) ||
        registry.containsDependency<Lazy<T>>(groupEntity: g)) {
      return true;
    }
    if (traverse) {
      for (final parent in parents) {
        if (parent.isRegistered<T>(groupEntity: g, traverse: true)) {
          return true;
        }
      }
    }
    return false;
  }

  /// Retrieves a synchronous dependency.
  Option<Sync<T>> getSync<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return get<T>(groupEntity: groupEntity, traverse: traverse).map(
      (e) => e.isSync()
          ? e.sync().unwrap()
          : Sync.value(Err('Called getSync() for an async dependency.')),
    );
  }

  @pragma('vm:prefer-inline')
  T call<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return getSyncUnsafe<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves a synchronous dependency.
  @pragma('vm:prefer-inline')
  T getSyncUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return getSync<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().value.unwrap();
  }

  @pragma('vm:prefer-inline')
  Option<Async<T>> getAsync<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return get<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.toAsync());
  }

  /// Retrieves an asynchronous dependency unsafely, returning a future of the
  /// instance or throwing an error if not found.
  @pragma('vm:prefer-inline')
  Future<T> getAsyncUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return Future.sync(() async {
      final result = await getAsync<T>(
        groupEntity: groupEntity,
        traverse: traverse,
      ).unwrap().value;
      return result.unwrap();
    });
  }

  /// Retrieves a synchronous dependency or `None` if not found or async.
  Option<T> getSyncOrNone<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final option = get<T>(groupEntity: groupEntity, traverse: traverse);
    if (option.isNone()) {
      return const None();
    }
    final resolvable = option.unwrap();
    if (resolvable.isAsync()) {
      return const None();
    }
    final result = resolvable.sync().unwrap().value;
    if (result.isErr()) {
      return const None();
    }
    final value = result.unwrap();
    return Some(value);
  }

  /// Retrieves a dependency from the container.
  Option<Resolvable<T>> get<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final g = groupEntity.preferOverDefault(focusGroup);
    final option = getDependency<T>(groupEntity: g, traverse: traverse);
    if (option.isNone()) {
      return const None();
    }
    final result = option.unwrap();
    if (result.isErr()) {
      return Some(Sync.value(result.err().unwrap().transErr()));
    }
    final dependency = result.unwrap();
    if (dependency.value.isSync()) {
      return Some(dependency.value);
    }
    return Some(dependency.cacheAsyncValue());
  }

  // NOTE: MAY WANT TO REVER IT THIS THROWS!!!
  // Option<Resolvable<T>> get<T extends Object>({
  //   Entity groupEntity = const DefaultEntity(),
  //   bool traverse = true,
  // }) {
  //   assert(T != Object, 'T must be specified and cannot be Object.');
  //   final g = groupEntity.preferOverDefault(focusGroup);
  //   final option = getDependency<T>(groupEntity: g, traverse: traverse);
  //   if (option.isNone()) {
  //     return const None();
  //   }
  //   final result = option.unwrap();
  //   if (result.isErr()) {
  //     return Some(Sync.value(result.err().unwrap().transErr()));
  //   }
  //   final dependency = result.unwrap();
  //   final value = dependency.value;
  //   if (value.isSync()) {
  //     return Some(value);
  //   }
  //   return Some(
  //     Async(
  //       () => value.async().unwrap().value.then((e) {
  //         final value = e.unwrap();
  //         registry.removeDependency<T>(groupEntity: g);
  //         registerDependency<T>(
  //           dependency: Dependency<T>(
  //             Sync.value(Ok(value)),
  //             metadata: option.unwrap().unwrap().metadata,
  //           ),
  //           checkExisting: false,
  //         );
  //         return value;
  //       }),
  //     ),
  //   );
  // }

  /// Retrieves a dependency unsafely, returning the instance or a future of it,
  /// or throwing an error if not found.
  @pragma('vm:prefer-inline')
  FutureOr<T> getUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    return get<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().unwrap();
  }

  /// Retrieves the underlying `Dependency` object from the registry.
  @protected
  Option<Result<Dependency<T>>> getDependency<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    final option = registry.getDependency<T>(groupEntity: g);
    var temp = option.map((e) => Ok(e).transf<Dependency<T>>());
    if (option.isNone() && traverse) {
      for (final parent in parents) {
        temp = parent.getDependency<T>(groupEntity: g);
        if (temp.isSome()) {
          break;
        }
      }
    }
    return temp;
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<TSuper> untilSuper<TSuper extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return until<TSuper, TSuper>(groupEntity: groupEntity, traverse: traverse);
  }

  /// Waits until a dependency of type `TSuper` or its subtype `TSub` is
  /// registered. `TSuper` should typically be the most general type expected.
  Resolvable<TSub> until<TSuper extends Object, TSub extends TSuper>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final typeEntity = TypeEntity(TSuper);
    final g = groupEntity.preferOverDefault(focusGroup);
    final test = get<TSuper>(groupEntity: g);
    if (test.isSome()) {
      return test.unwrap().transf();
    }
    ReservedSafeFinisher<TSuper>? finisher;
    var temp = getSyncOrNone<ReservedSafeFinisher<TSuper>>(
      groupEntity: g,
      traverse: traverse,
    );
    if (temp.isSome()) {
      finisher = temp.unwrap();
    } else {
      finisher = ReservedSafeFinisher<TSuper>(typeEntity);
      register(finisher, groupEntity: g);
    }
    return finisher
        .resolvable()
        .map((_) {
          unregister<ReservedSafeFinisher<TSuper>>(groupEntity: g);
          return get<TSuper>(groupEntity: g).unwrap();
        })
        .comb2()
        .transf();
  }
}

// Source: ./lib/src/core/di/dep.dart
// TODO: Create a Fluent API one called Dep/
class Dep {}

// Source: ./lib/src/core/di/_mixins/supports_constructors_mixin_k.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides methods for working with constructors of dependencies,
/// using `Entity` for type resolution.
base mixin SupportsConstructorsMixinK on SupportsMixinK {
  /// Retrieves the lazily loaded singleton dependency.
  @protected
  @pragma('vm:prefer-inline')
  Resolvable<None> unregisterLazyK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
    bool triggerOnUnregisterCallbacks = true,
  }) {
    return unregisterK(
      TypeEntity(Lazy, [typeEntity]),
      groupEntity: groupEntity,
      traverse: traverse,
      removeAll: removeAll,
      triggerOnUnregisterCallbacks: triggerOnUnregisterCallbacks,
    );
  }

  /// Retrieves the lazily loaded dependency.
  @protected
  @pragma('vm:prefer-inline')
  Option<Resolvable<Lazy<T>>> getLazyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getK<Lazy<T>>(
      TypeEntity(Lazy, [typeEntity]),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the lazily loaded dependency, returning the instance directly or
  /// throwing an error if not found.
  @protected
  @pragma('vm:prefer-inline')
  FutureOr<Lazy<T>> getLazyUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazyK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.unwrap()).unwrap();
  }

  /// You must register dependencies via [register] and set its parameter
  /// `enableUntilExactlyK` to true to use this method.
  @protected
  @pragma('vm:prefer-inline')
  Resolvable<Lazy<T>> untilLazyExactlyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilExactlyK<Lazy<T>>(
      TypeEntity(Lazy, [typeEntity]),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Resets the singleton instance of a lazily loaded dependency.
  @protected
  Resolvable<None> resetLazySingletonK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final temp = getK<T>(
      TypeEntity(Lazy, [typeEntity]),
      groupEntity: groupEntity,
    );
    if (temp.isSome()) {
      return temp.unwrap().map((e) {
        (e as Lazy).resetSingleton();
        return const None();
      });
    }
    return const Sync.value(Ok(None()));
  }

  /// Retrieves the lazily loaded singleton dependency.
  @protected
  Option<Resolvable<T>> getLazySingletonK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final option = getLazyK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    );
    if (option.isNone()) {
      return const None();
    }
    final lazy = option.unwrap().sync().unwrap().unwrap();
    return Some(lazy.singleton);
  }

  /// Retrieves the lazily loaded singleton dependency unsafely, returning the
  /// instance directly or throwing an error if not found or not a singleton.
  @protected
  @pragma('vm:prefer-inline')
  FutureOr<T> getLazySingletonUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazySingletonK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().unwrap();
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> untilLazySingletonyExactlyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazyExactlyK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.singleton).comb2();
  }

  /// Retrieves the factory dependency.
  @protected
  Option<Resolvable<T>> getFactoryK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final option = getLazyK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    );
    if (option.isNone()) {
      return const None();
    }
    final lazy = option.unwrap().sync().unwrap().unwrap();
    return Some(lazy.factory);
  }

  /// Retrieves the factory dependency, returning the instance directly or
  /// throwing an error if not found.
  @protected
  @pragma('vm:prefer-inline')
  FutureOr<T> getFactoryUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getFactoryK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().unwrap();
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<T> untilFactoryExactlyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazyExactlyK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.factory).comb2();
  }
}

// Source: ./lib/src/core/di/_mixins/supports_children_mixin.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

base mixin SupportsChildrenMixin on SupportsConstructorsMixin {
  Resolvable<Lazy<DI>> registerChild({
    Entity groupEntity = const DefaultEntity(),
  }) {
    if (childrenContainer.isNone()) {
      childrenContainer = Some(DI());
    }
    return childrenContainer.unwrap().registerLazy<DI>(
          () => Sync.value(Ok(DI()..parents.add(this as DI))),
          groupEntity: groupEntity,
        );
  }

  Option<DI> getChildOrNone({Entity groupEntity = const DefaultEntity()}) {
    final option = getChild(groupEntity: groupEntity);
    if (option.isNone()) {
      return const None();
    }
    final result = option.unwrap();
    if (result.isErr()) {
      return const None();
    }
    return Some(result.unwrap());
  }

  Option<Result<DI>> getChild({Entity groupEntity = const DefaultEntity()}) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return const None();
    }
    final option = childrenContainer.unwrap().getLazySingleton<DI>(
          groupEntity: g,
        );
    if (option.isNone()) {
      return const None();
    }
    final result = option.unwrap().sync();
    if (result.isErr()) {
      return Some(result.err().unwrap().transErr());
    }
    final value = result.unwrap().value;
    return Some(value);
  }

  Option<Result<DI>> getChildT({Entity groupEntity = const DefaultEntity()}) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return const None();
    }
    final option = childrenContainer.unwrap().getLazySingletonT<DI>(
          DI,
          groupEntity: g,
        );
    if (option.isNone()) {
      return const None();
    }
    final result = option.unwrap().sync();
    if (result.isErr()) {
      return Some(result.err().unwrap().transErr());
    }
    final value = result.unwrap().value.transf<DI>();
    return Some(value);
  }

  Result<None> unregisterChild({Entity groupEntity = const DefaultEntity()}) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return Err('No child container registered.');
    }
    return childrenContainer.unwrap().unregister<DI>(groupEntity: g).sync().unwrap().value;
  }

  Result<None> unregisterChildT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return Err('No child container registered.');
    }
    return childrenContainer.unwrap().unregisterT(type, groupEntity: g).sync().unwrap().value;
  }

  bool isChildRegistered<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return false;
    }
    return childrenContainer.unwrap().isRegistered<DI>(groupEntity: g);
  }

  bool isChildRegisteredT<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (childrenContainer.isNone()) {
      return false;
    }
    return childrenContainer.unwrap().isRegisteredT(DI, groupEntity: g);
  }

  DI child({Entity groupEntity = const DefaultEntity()}) {
    if (isChildRegistered(groupEntity: groupEntity)) {
      return getChild(groupEntity: groupEntity).unwrap().unwrap();
    }
    registerChild(groupEntity: groupEntity);
    return getChild(groupEntity: groupEntity).unwrap().unwrap();
  }
}

// Source: ./lib/src/core/di/_mixins/supports_constructors_mixin_t.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides methods for working with constructors of dependencies,
/// using `Type` for type resolution.
base mixin SupportsConstructorsMixinT on SupportsConstructorsMixinK {
  /// Unregisters a lazily loaded dependency.
  @pragma('vm:prefer-inline')
  Resolvable<None> unregisterLazyT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
    bool triggerOnUnregisterCallbacks = true,
  }) {
    return unregisterLazyK(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
      removeAll: removeAll,
      triggerOnUnregisterCallbacks: triggerOnUnregisterCallbacks,
    );
  }

  /// Retrieves the lazily loaded dependency.
  @pragma('vm:prefer-inline')
  Option<Resolvable<Lazy<T>>> getLazyT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the lazily loaded dependency, returning the instance directly or
  /// throwing an error if not found or not a singleton.
  @protected
  @pragma('vm:prefer-inline')
  FutureOr<Lazy<T>> getLazyUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazyUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// You must register dependencies via [register] and set its parameter
  /// `enableUntilExactlyK` to true to use this method.
  @pragma('vm:prefer-inline')
  Resolvable<Lazy<T>> untilLazyExactlyT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazyExactlyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Resets the singleton instance of a lazily loaded dependency.
  @pragma('vm:prefer-inline')
  Resolvable<None> resetLazySingletonT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    return resetLazySingletonK<T>(TypeEntity(type), groupEntity: groupEntity);
  }

  /// Retrieves the lazily loaded singleton dependency.
  @pragma('vm:prefer-inline')
  Option<Resolvable<T>> getLazySingletonT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazySingletonK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the lazily loaded singleton dependency unsafely, returning the
  /// instance directly or throwing an error if not found or not a singleton.
  @pragma('vm:prefer-inline')
  FutureOr<Object> getLazySingletonUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazySingletonUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<T> untilLazySingletonyExactlyT<T extends Object>(
    T type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazySingletonyExactlyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the factory dependency.
  @pragma('vm:prefer-inline')
  Option<Resolvable<T>> getFactoryT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getFactoryK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the factory dependency unsafely, returning the instance directly
  /// or throwing an error if not found.
  @pragma('vm:prefer-inline')
  FutureOr<T> getFactoryUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getFactoryUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<T> untilFactoryExactlyT<T extends Object>(
    T type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilFactoryExactlyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }
}

// Source: ./lib/src/core/di/_mixins/supports_constructors_mixin.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides methods for working with constructors of dependencies,
/// using generic types for type resolution.
base mixin SupportsConstructorsMixin on DIBase {
  /// Registers a lazy dependency.
  @pragma('vm:prefer-inline')
  Resolvable<Lazy<T>> registerLazy<T extends Object>(
    LazyConstructor<T> constructor, {
    FutureOr<void> Function(Lazy<T> lazy)? onRegister,
    TOnUnregisterCallback<Lazy<T>>? onUnregister,
    Entity groupEntity = const DefaultEntity(),
  }) {
    return register<Lazy<T>>(
      Lazy<T>(constructor),
      onRegister: onRegister,
      onUnregister: onUnregister,
      groupEntity: groupEntity,
    );
  }

  /// Unregisters a lazily loaded dependency.
  @pragma('vm:prefer-inline')
  Resolvable<None<Object>> unregisterLazy<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
    bool triggerOnUnregisterCallbacks = true,
  }) {
    return unregister<Lazy<T>>(
      groupEntity: groupEntity,
      traverse: traverse,
      removeAll: removeAll,
      triggerOnUnregisterCallbacks: triggerOnUnregisterCallbacks,
    );
  }

  /// Retrieves the lazily loaded dependency.
  @pragma('vm:prefer-inline')
  Option<Resolvable<Lazy<T>>> getLazy<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return get<Lazy<T>>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the lazily loaded singleton dependency unsafely, returning the
  /// instance directly or throwing an error if not found or not a singleton.
  @pragma('vm:prefer-inline')
  FutureOr<Lazy<T>> getLazyUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazy<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.unwrap()).unwrap();
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<Lazy<TSuper>> untilLazySuper<TSuper extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilSuper<Lazy<TSuper>>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency of type `TSuper` or its subtype `TSub` is
  /// registered. `TSuper` should typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<Lazy<TSub>> untilLazy<TSuper extends Object, TSub extends TSuper>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return until<Lazy<TSuper>, Lazy<TSub>>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Resets the singleton instance of a lazily loaded dependency.
  Resolvable<None> resetLazySingleton<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
  }) {
    final temp = getLazy<T>(groupEntity: groupEntity);
    if (temp.isSome()) {
      return temp.unwrap().map((e) {
        e.resetSingleton();
        return const None();
      });
    }
    return const Sync.value(Ok(None()));
  }

  /// Retrieves the lazily loaded singleton dependency.
  Option<Resolvable<T>> getLazySingleton<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final option = getLazy<T>(groupEntity: groupEntity, traverse: traverse);
    if (option.isNone()) {
      return const None();
    }
    final lazy = option.unwrap().sync().unwrap().unwrap();
    return Some(lazy.singleton);
  }

  /// Retrieves the lazily loaded singleton dependency unsafely, returning the
  /// instance directly or throwing an error if not found or not a singleton.
  @pragma('vm:prefer-inline')
  FutureOr<T> getLazySingletonUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getLazySingleton<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.unwrap()).unwrap();
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<TSuper> untilLazySingletonSuper<TSuper extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazySingleton<TSuper, TSuper>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency of type `TSuper` or its subtype `TSub` is
  /// registered. `TSuper` should typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<TSub> untilLazySingleton<TSuper extends Object, TSub extends TSuper>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazy<TSuper, TSub>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.singleton).comb2();
  }

  /// Retrieves the factory dependency.
  Option<Resolvable<T>> getFactory<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final option = getLazy<T>(groupEntity: groupEntity, traverse: traverse);
    if (option.isNone()) {
      return const None();
    }
    final lazy = option.unwrap().sync().unwrap().unwrap();
    return Some(lazy.factory);
  }

  /// Retrieves the factory dependency unsafely, returning the instance directly
  /// or throwing an error if not found.
  @pragma('vm:prefer-inline')
  FutureOr<T> getFactoryUnsafe<T extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getFactory<T>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.unwrap()).unwrap();
  }

  /// Waits until a dependency of type `TSuper` is registered. `TSuper` should
  /// typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<TSuper> untilFactorySuper<TSuper extends Object>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilFactory<TSuper, TSuper>(
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency of type `TSuper` or its subtype `TSub` is
  /// registered. `TSuper` should typically be the most general type expected.
  @pragma('vm:prefer-inline')
  Resolvable<TSub> untilFactory<TSuper extends Object, TSub extends TSuper>({
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilLazy<TSuper, TSub>(
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.factory).comb2();
  }
}

// Source: ./lib/src/core/di/_mixins/supports_mixin_k.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '/src/_common.dart';
// import '/src/core/_reserved_safe_finisher.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides methods for working with dependencies,
/// using `Entity` for type resolution.
base mixin SupportsMixinK on DIBase {
  /// Retrieves the synchronous dependency unsafely, returning the instance
  /// directly.
  @pragma('vm:prefer-inline')
  T getSyncUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getSyncK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().value.unwrap();
  }

  /// Retrieves the synchronous dependency.
  Option<Sync<T>> getSyncK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).map(
      (e) => e.isSync()
          ? e.sync().unwrap()
          : Sync.value(Err('Called getSyncK() an async dependency.')),
    );
  }

  /// Retrieves an asynchronous dependency unsafely, returning a future of the
  /// instance, directly or throwing an error if not found.
  @pragma('vm:prefer-inline')
  Future<T> getAsyncUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return Future.sync(() async {
      final result = await getAsyncK<T>(
        typeEntity,
        groupEntity: groupEntity,
        traverse: traverse,
      ).unwrap().value;
      return result.unwrap();
    });
  }

  /// Retrieves an asynchronous dependency.
  @pragma('vm:prefer-inline')
  Option<Async<T>> getAsyncK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).map((e) => e.toAsync());
  }

  /// Retrieves a dependency unsafely, returning it directly or throwing an
  /// error if not found.
  @pragma('vm:prefer-inline')
  FutureOr<T> getUnsafeK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    ).unwrap().unwrap();
  }

  /// Retrieves the synchronous dependency or `None` if not found or async.
  Option<T> getSyncOrNoneK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final option = getK<T>(
      typeEntity,
      groupEntity: groupEntity,
      traverse: traverse,
    );
    if (option.isNone()) {
      return const None();
    }
    final resolvable = option.unwrap();
    if (resolvable.isAsync()) {
      return const None();
    }
    final result = resolvable.sync().unwrap().value;
    if (result.isErr()) {
      return const None();
    }
    final value = result.transf<T>().unwrap();
    return Some(value);
  }

  /// Retrieves the dependency.
  Option<Resolvable<T>> getK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    final option = getDependencyK<T>(
      typeEntity,
      groupEntity: g,
      traverse: traverse,
    );
    if (option.isNone()) {
      return const None();
    }
    final result = option.unwrap();
    if (result.isErr()) {
      return Some(Sync.value(result.err().unwrap().transErr()));
    }
    final value = result.unwrap().value;
    if (value.isSync()) {
      return Some(value);
    }
    return Some(
      Async(
        () => value.async().unwrap().value.then((e) {
          final value = e.unwrap();
          registry.removeDependencyK(typeEntity, groupEntity: g);
          final metadata = option.unwrap().unwrap().metadata.map(
                (e) => e.copyWith(
                  preemptivetypeEntity: TypeEntity(Sync, [typeEntity]),
                ),
              );
          registerDependencyK(
            dependency: Dependency(Sync.value(Ok(value)), metadata: metadata),
            checkExisting: false,
          );
          return value;
        }),
      ),
    );
  }

  /// Retrieves the underlying `Dependency` object.
  Result<Dependency<T>> registerDependencyK<T extends Object>({
    required Dependency<T> dependency,
    bool checkExisting = false,
  }) {
    final g = dependency.metadata.isSome() ? dependency.metadata.unwrap().groupEntity : focusGroup;
    if (checkExisting) {
      final option = getDependencyK(
        dependency.typeEntity,
        groupEntity: g,
        traverse: false,
      );
      if (option.isSome()) {
        return Err('Dependency already registered.');
      }
    }
    registry.setDependency(dependency);
    return Ok(dependency);
  }

  /// Retrieves the underlying `Dependency` object.
  Option<Result<Dependency<T>>> getDependencyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    final option = registry.getDependencyK(typeEntity, groupEntity: g);
    var temp = option.map((e) => Ok(e).transf<Dependency<T>>());
    if (option.isNone() && traverse) {
      for (final parent in parents) {
        temp = (parent as SupportsMixinK).getDependencyK(
          typeEntity,
          groupEntity: g,
        );
        if (temp.isSome()) {
          break;
        }
      }
    }
    return temp;
  }

  /// Unregisters a dependency.
  Resolvable<None> unregisterK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
    bool triggerOnUnregisterCallbacks = true,
  }) {
    final sequential = SafeSequential();
    final g = groupEntity.preferOverDefault(focusGroup);
    for (final di in [this as DI, ...parents]) {
      final dependencyOption = di.removeDependencyK(typeEntity, groupEntity: g);
      if (dependencyOption.isNone()) {
        continue;
      }
      if (triggerOnUnregisterCallbacks) {
        final dependency = dependencyOption.unwrap();
        final metadataOption = dependency.metadata;

        if (metadataOption.isSome()) {
          final metadata = metadataOption.unwrap();
          final onUnregisterOption = metadata.onUnregister;
          if (onUnregisterOption.isSome()) {
            final onUnregister = onUnregisterOption.unwrap();
            sequential.addSafe((_) => dependency.value.map((e) => Some(e)));
            sequential.addSafe((e) {
              final option = e.swap();
              if (option.isSome()) {
                final result = option.unwrap();
                return onUnregister(result);
              }
              return null;
            });
          }
        }
      }
      if (!removeAll) {
        break;
      }
    }
    return sequential.last;
  }

  /// Removes a dependency from the registry.
  @pragma('vm:prefer-inline')
  Option<Dependency> removeDependencyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    var result = registry.removeDependencyK(typeEntity, groupEntity: g);
    if (result.isNone()) {
      result = registry.removeDependencyK(
        TypeEntity(Lazy, [typeEntity]),
        groupEntity: g,
      );
    }
    return result;
  }

  /// Checks if a dependency is registered.
  bool isRegisteredK(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    if (registry.containsDependencyK(typeEntity, groupEntity: g) ||
        registry.containsDependencyK(
          TypeEntity(Lazy, [typeEntity]),
          groupEntity: g,
        )) {
      return true;
    }
    if (traverse) {
      for (final parent in parents) {
        if ((parent as SupportsMixinK).isRegisteredK(
          typeEntity,
          groupEntity: g,
          traverse: true,
        )) {
          return true;
        }
      }
    }
    return false;
  }

  /// Waits until a dependency with the exact `typeEntity` is registered.
  /// The result is cast to `T`.
  ///
  /// **Note:** Requires `enableUntilExactlyK: true` during registration.
  /// If `typeEntity` doesn't match an existing or future registration exactly,
  /// this will not resolve.
  Resolvable<T> untilExactlyK<T extends Object>(
    Entity typeEntity, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    final g = groupEntity.preferOverDefault(focusGroup);
    final test = getK(typeEntity, groupEntity: g);
    if (test.isSome()) {
      return test.unwrap().map((e) => e as T);
    }
    var finisher = finishersK[g]?.firstWhereOrNull(
      (e) => e.typeEntity == typeEntity,
    );
    if (finisher == null) {
      finisher = ReservedSafeFinisher(typeEntity);
      (finishersK[g] ??= []).add(finisher);
    }
    return finisher.resolvable().map((_) {
      final temp = finishersK[g] ?? [];
      for (var n = 0; n < temp.length; n++) {
        final e = temp[n];
        if (e.typeEntity == typeEntity) {
          temp.removeAt(n);
          break;
        }
      }
      return getK<T>(typeEntity, groupEntity: g).unwrap();
    }).comb2();
  }

  /// Stores finishers for [untilExactlyK].
  final finishersK = <Entity, List<ReservedSafeFinisher>>{};

  /// Attempts to finish any pending [untilExactlyK] calls for the given
  /// type and group.
  void maybeFinishK<T extends Object>({required Entity g}) {
    assert(T != Object, 'T must be specified and cannot be Object.');
    final typeEntity = TypeEntity(T);
    for (final di in [this as DI, ...children().unwrapOr([])]) {
      final test = di.finishersK[g]?.firstWhereOrNull((e) {
        return e is ReservedSafeFinisher<T> || e.typeEntity == typeEntity;
      });
      if (test != null) {
        test.finish(const None());
        break;
      }
    }
  }
}

// Source: ./lib/src/core/di/_mixins/_mixins.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './supports_constructors_mixin_k.dart';
export './supports_children_mixin.dart';
export './supports_constructors_mixin_t.dart';
export './supports_constructors_mixin.dart';
export './supports_mixin_k.dart';
export './supports_unregister_all.dart';
export './supports_mixin_t.dart';

// Source: ./lib/src/core/di/_mixins/supports_unregister_all.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides a method to unregister all dependencies.
base mixin SupportsUnregisterAll on DIBase {
  /// Unregisters all dependencies, optionally with callbacks and conditions.
  Resolvable<None> unregisterAll({
    TOnUnregisterCallback<Dependency>? onBeforeUnregister,
    TOnUnregisterCallback<Dependency>? onAfterUnregister,
    bool Function(Dependency)? condition,
  }) {
    final results = List.of(registry.reversedDependencies);
    final sequential = SafeSequential();
    for (final dependency in results) {
      sequential
        ..addSafe((_) {
          return onBeforeUnregister?.call(Ok(dependency));
        })
        ..addSafe((_) {
          if (condition != null && !condition(dependency)) {
            return null;
          }
          registry.removeDependencyK(
            dependency.typeEntity,
            groupEntity:
                dependency.metadata.map((e) => e.groupEntity).unwrapOr(const DefaultEntity()),
          );
          final metadataOption = dependency.metadata;
          if (metadataOption.isSome()) {
            final metadata = metadataOption.unwrap();
            final onUnregisterOption = metadata.onUnregister;
            if (onUnregisterOption.isSome()) {
              final onUnregister = onUnregisterOption.unwrap();
              return dependency.value
                  .map((e) => onUnregister(Ok(e)) ?? SyncOk.value(const None()))
                  .comb();
            }
          }
          return null;
        })
        ..addSafe((_) {
          return onAfterUnregister?.call(Ok(dependency));
        });
    }
    return sequential.last;
  }
}

// Source: ./lib/src/core/di/_mixins/supports_mixin_t.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A mixin that provides methods for working with dependencies,
/// using `Type` for type resolution.
base mixin SupportsMixinT on SupportsMixinK {
  /// Retrieves the synchronous dependency unsafely, returning the instance
  /// directly.
  @pragma('vm:prefer-inline')
  T getSyncUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getSyncUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the synchronous dependency.
  @pragma('vm:prefer-inline')
  Option<Sync<T>> getSyncT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getSyncK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves an asynchronous dependency unsafely, returning a future of the
  /// instance, directly or throwing an error if not found.
  @pragma('vm:prefer-inline')
  Future<T> getAsyncUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getAsyncUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves an asynchronous dependency.
  @pragma('vm:prefer-inline')
  Option<Async<T>> getAsyncT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getAsyncK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves a dependency unsafely, returning it directly or throwing an
  /// error if not found.
  @pragma('vm:prefer-inline')
  FutureOr<T> getUnsafeT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getUnsafeK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the synchronous dependency or `None` if not found or async.
  @pragma('vm:prefer-inline')
  Option<T> getSyncOrNoneT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getSyncOrNoneK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the dependency.
  @pragma('vm:prefer-inline')
  Option<Resolvable<T>> getT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Retrieves the underlying `Dependency` object.
  @pragma('vm:prefer-inline')
  Option<Result<Dependency<T>>> getDependencyT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return getDependencyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Unregisters a dependency.
  @pragma('vm:prefer-inline')
  Resolvable<None> unregisterT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
    bool removeAll = true,
  }) {
    return unregisterK(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
      removeAll: removeAll,
    );
  }

  /// Removes a dependency from the registry.
  @protected
  @pragma('vm:prefer-inline')
  Option<Dependency> removeDependencyT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
  }) {
    return removeDependencyK<T>(TypeEntity(type), groupEntity: groupEntity);
  }

  /// Checks if a dependency is registered.
  @pragma('vm:prefer-inline')
  bool isRegisteredT(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return isRegisteredK(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }

  /// Waits until a dependency with the exact `typeEntity` is registered.
  /// The result is cast to `T`.
  ///
  /// **Note:** Requires `enableUntilExactlyK: true` during registration.
  /// If `typeEntity` doesn't match an existing or future registration exactly,
  /// this will not resolve.
  @pragma('vm:prefer-inline')
  Resolvable<T> untilExactlyT<T extends Object>(
    Type type, {
    Entity groupEntity = const DefaultEntity(),
    bool traverse = true,
  }) {
    return untilExactlyK<T>(
      TypeEntity(type),
      groupEntity: groupEntity,
      traverse: traverse,
    );
  }
}

// Source: ./lib/src/core/entity/reserved_entities.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'entity.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A predefined entity recommended to use as the default group entity for
/// dependencies. This entity can be utilized when no specific group is
/// defined, allowing for a fallback option that simplifies dependency
/// retrieval and management in the DI container.
final class DefaultEntity extends Entity {
  const DefaultEntity() : super.reserved(-1001);
}

/// A predefined entity recommended to use as the global Entity entity for
/// dependencies. Use This entity for dependencies that need to be accessible
/// throughout the entire application, regardless of the current scope or
/// context. This is ideal for singleton services or configurations that
/// should remain consistent across all parts of the application.
final class GlobalEntity extends Entity {
  const GlobalEntity() : super.reserved(-1002);
}

/// A predefined entity recommended to use as the global group entity for
/// dependencies. Use This entity for dependencies that need to be accessible
/// throughout the entire application, regardless of the current scope or
/// context. This is ideal for singleton services or configurations that
/// should remain consistent across all parts of the application.
final class SessionEntity extends Entity {
  const SessionEntity() : super.reserved(-1003);
}

// A predefined entity recommended to use as the user group entity for
/// dependencies. This entity is designed for managing dependencies
/// that are user-specific, such as user preferences, settings,
/// or any other data that varies from user to user. It helps
/// organize services related to user management.
final class UserEntity extends Entity {
  const UserEntity() : super.reserved(-1004);
}

/// A predefined entity recommended to use as the theme group entity for
/// dependencies. This entity is suitable for managing theme-related
/// services or configurations that control the application's
/// visual appearance. It allows for easy access and modification
/// of UI themes, such as light or dark modes.
final class ThemeEntity extends Entity {
  const ThemeEntity() : super.reserved(-1005);
}

/// A predefined entity recommended to use as the production group entity for
/// dependencies. This entity is intended for services that are specific
/// to the production environment, ensuring that production-only
/// configurations or resources are appropriately managed and
/// distinguished from other environments (like development or testing).
final class ProdEntity extends Entity {
  const ProdEntity() : super.reserved(-1006);
}

/// A predefined entity recommended to use as the development group entity for
/// dependencies. This entity is useful for managing services that are
/// intended for development purposes, such as debugging tools,
/// mock services, or any other resources that assist during the
/// development process. It helps isolate development-specific.
final class DevEntity extends Entity {
  const DevEntity() : super.reserved(-1007);
}

/// A predefined entity recommended to use as the test group entity for
/// dependencies. This entity is designated for managing services that
/// are utilized during testing, allowing for easy access to mock
/// dependencies, test doubles, or any configurations necessary
/// for unit tests and integration tests. It ensures that test
/// services do not interfere with the application's production or
/// development dependencies.
final class TestEntity extends Entity {
  const TestEntity() : super.reserved(-1008);
}

// Source: ./lib/src/core/entity/type_entity.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: prefer_single_quotes

// import 'entity.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Constructs a `Entity` representation by replacing occurrences of `Object`
/// or `dynamic` in the `baseType` with corresponding values from `subTypes`.
/// The replacements are applied sequentially based on their order in
/// `subTypes`.
///
/// If no `subTypes` are provided, the method returns the `baseType` as-is
/// (after trimming spaces).
///
/// ### Examples:
/// ```dart
/// // Example 1: Replacing multiple generic placeholders
/// final type1 = TypeEntity(Map<Object, Object>, [String, int]);
/// print(type1); // Output: Map<String,int>
///
/// // Example 2: Replacing `dynamic`
/// final type2 = TypeEntity('List<dynamic>', ['int']);
/// print(type2); // Output: List<int>
///
/// // Example 3: Handling non-generic types
/// final type3 = TypeEntity(int);
/// print(type3); // Output: int
///
/// // Example 4: More complex generics
/// final type4 = TypeEntity(Map<dynamic, List<Object>>, ['String', 'int']);
/// print(type4); // Output: Map<String,List<int>>
/// ```
final class TypeEntity extends Entity {
  //
  //
  //

  final String _typeString;

  //
  //
  //

  static String _getTypeString(dynamic object) {
    if (object is TypeEntity) {
      return object._typeString;
    }
    return object.toString().replaceAll(' ', '');
  }

  //
  //
  //

  TypeEntity._obj(String typeString)
      : _typeString = typeString,
        super(Entity.objId(typeString));

  //
  //
  //

  factory TypeEntity(Object baseType, [List<Object> subTypes = const []]) {
    final initialCleanBaseTypeString = _getTypeString(baseType);
    String finalTypeString;

    if (subTypes.isNotEmpty) {
      final isSimpleIdentifier = !initialCleanBaseTypeString.contains(
        RegExp(r'[<>,?]'),
      );
      if (isSimpleIdentifier) {
        final subTypeStrings = subTypes.map((st) => _getTypeString(st)).join(',');
        finalTypeString = '$initialCleanBaseTypeString<$subTypeStrings>';
      } else {
        final objectPlaceholder = _getTypeString(Object);
        final objectNullablePlaceholder = "$objectPlaceholder?";
        final dynamicPlaceholder = _getTypeString(dynamic);

        var subTypeIndex = 0;
        final buffer = StringBuffer();
        var n = 0;
        while (n < initialCleanBaseTypeString.length) {
          var matched = false;
          if (initialCleanBaseTypeString.startsWith(
            objectNullablePlaceholder,
            n,
          )) {
            if (subTypeIndex < subTypes.length) {
              buffer.write(_getTypeString(subTypes[subTypeIndex]));
              subTypeIndex++;
            } else {
              buffer.write(objectNullablePlaceholder);
            }
            n += objectNullablePlaceholder.length;
            matched = true;
          } else if (initialCleanBaseTypeString.startsWith(
            objectPlaceholder,
            n,
          )) {
            if (subTypeIndex < subTypes.length) {
              buffer.write(_getTypeString(subTypes[subTypeIndex]));
              subTypeIndex++;
            } else {
              buffer.write(objectPlaceholder);
            }
            n += objectPlaceholder.length;
            matched = true;
          } else if (initialCleanBaseTypeString.startsWith(
            dynamicPlaceholder,
            n,
          )) {
            if (subTypeIndex < subTypes.length) {
              buffer.write(_getTypeString(subTypes[subTypeIndex]));
              subTypeIndex++;
            } else {
              buffer.write(dynamicPlaceholder);
            }
            n += dynamicPlaceholder.length;
            matched = true;
          }
          if (!matched) {
            buffer.write(initialCleanBaseTypeString[n]);
            n++;
          }
        }
        finalTypeString = buffer.toString();
      }
    } else {
      finalTypeString = initialCleanBaseTypeString;
    }
    return TypeEntity._obj(finalTypeString);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

final class GenericEntity<T> extends TypeEntity {
  //
  //
  //

  GenericEntity._(super.typeString) : super._obj();

  //
  //
  //

  factory GenericEntity() {
    // This will use the TypeEntity factory to construct the canonical string for T
    final typeEntityInstanceForT = TypeEntity(T);
    return GenericEntity._(typeEntityInstanceForT._typeString);
  }
}

// Source: ./lib/src/core/entity/entity.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:meta/meta.dart' show protected;

// import 'reserved_entities.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// An entity is a uniquely identifiable object that serves as a container or
/// identifier for components in a Dependency Injection (DI) or
/// Entity-Component-System (ECS) framework.
class Entity {
  /// Creates an integer [id] from the specified [object]. If the object
  /// is already an [int], it is returned as is. Otherwise, the object is
  /// converted to a string with spaces removed, then the [hashCode] is
  /// calculated and returned.
  @protected
  @pragma('vm:prefer-inline')
  static int objId(Object object) =>
      object is int ? object : object.toString().replaceAll(' ', '').hashCode;

  /// The value associated with this Entity instance.
  final int id;

  /// Creates a new instance of [Entity] identified by [id]. The [id] must be 0
  /// or greater.
  const Entity(this.id) : assert(id >= 0, 'Entity id must be 0 or greater!');

  @pragma('vm:prefer-inline')
  bool isDefault() => id == const DefaultEntity().id;

  /// Returns [other] if `this` is [DefaultEntity], otherwise returns `this`.
  @pragma('vm:prefer-inline')
  Entity preferOverDefault(Entity other) => isDefault() ? other : this;

  @pragma('vm:prefer-inline')
  bool isNotDefault() => !isDefault();

  /// Creates a new [Entity] with the given [id]. The [id] must be less than 0.
  ///
  /// Negative [id] values are reserved exclusively for internal use by the
  /// df_di package and [UniqueEntity]. They should not be used directly in
  /// your code.
  @protected
  const Entity.reserved(this.id)
    : assert(id < 0, 'Entity id must be negative!');

  /// Creates a new instance of [Entity] from the specified [object]. This
  /// effectively uses [objId] to convert the [object] to an [int] and then
  /// uses that as the [id] for the new [Entity] instance.
  factory Entity.obj(Object object) => Entity(objId(object));

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is Entity) {
      return other.hashCode == hashCode;
    } else {
      return id == objId(other);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  int get hashCode => id;

  @override
  @pragma('vm:prefer-inline')
  String toString() => id.toString();
}

// Source: ./lib/src/core/entity/unique_entity.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'entity.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Creates a new [UniqueEntity] with a unique ID.
final class UniqueEntity extends Entity {
  // Start at -10000 to avoid conflicts with other reserved values.
  static int _counter = -10000;
  UniqueEntity() : super.reserved(_counter--);
}

// Source: ./lib/src/core/_reserved_safe_finisher.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@internal
final class ReservedSafeFinisher<T extends Object> extends SafeFinisher<T> {
  //
  //
  //

  final Entity typeEntity;

  //
  //
  //

  ReservedSafeFinisher(this.typeEntity);

  //
  //
  //

  @override
  bool operator ==(Object other) => identical(this, other);

  //
  //
  //

  @override
  int get hashCode {
    final a = Object() is! T ? T.hashCode : typeEntity.hashCode;
    final b = (ReservedSafeFinisher).hashCode;
    return Object.hash(a, b);
  }
}

// Source: ./lib/src/core/services/service.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_debouncer/df_debouncer.dart';
// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Defines the possible lifecycle states of a [Service].
enum _ServiceState {
  NOT_INITIALIZED,
  BUSY_INITIALIZING,
  INITIALIZED,
  BUSY_DISPOSING,
  DISPOSED,
}

/// A base class for services that require initialization and disposal
/// management.
///
/// This class provides a robust, state-managed structure for service
/// lifecycles, ensuring they are properly initialized and disposed of, even
/// under concurrent access. It is intended for use within a Dependency
/// Injection (DI) system.
abstract class Service<TParams extends Option> {
  Service();

  static Resolvable<None> unregister(Result<Service> e) {
    return Resolvable(() => consec(e.unwrap().dispose(), (_) => const None()));
  }

  // --- STATE MANAGEMENT ------------------------------------------------------

  var _state = _ServiceState.NOT_INITIALIZED;
  // ✅ Use Option to make the potential absence of a finisher explicit.
  Option<SafeFinisher<None>> _operationFinisher = const None();

  /// Returns `true` if the service has been successfully initialized.
  bool get initialized => _state == _ServiceState.INITIALIZED;

  /// Returns `true` if the service has been disposed or is being disposed.
  bool get disposed => _state == _ServiceState.DISPOSED || _state == _ServiceState.BUSY_DISPOSING;

  // --- INITIALIZATION OF SERVICE ---------------------------------------------

  /// Initializes the service, making it ready for use.
  @nonVirtual
  FutureOr<void> init(TParams params) {
    if (_state == _ServiceState.INITIALIZED) return const None();

    if (_state == _ServiceState.BUSY_INITIALIZING) {
      return consec(_operationFinisher.unwrap().resolvable().value, (_) {});
    }

    if (disposed) {
      throw StateError('Cannot initialize a service that has been disposed.');
    }

    _state = _ServiceState.BUSY_INITIALIZING;
    _operationFinisher = Some(SafeFinisher<None>());

    try {
      final sequential = Sequential();
      sequential.addAll([
        ...provideInitListeners().map((e) => (_) => e(params)),
        (_) => _state = _ServiceState.INITIALIZED,
      ]);

      return consec(
        sequential.last,
        (_) {
          _operationFinisher.ifSome((f) => f.unwrap().finish(const None()));
        },
        onError: (e) {
          _state = _ServiceState.DISPOSED;
          _operationFinisher.ifSome((f) => f.unwrap()..resolve(Sync.value(Err(e))));
        },
      );
    } catch (e) {
      _state = _ServiceState.DISPOSED;
      _operationFinisher.ifSome((f) => f.unwrap()..resolve(Sync.value(Err(e))));
      rethrow;
    }
  }

  @mustCallSuper
  TServiceListeners<TParams> provideInitListeners() => [];

  // --- RESTARTING OF SERVICE -------------------------------------------------

  late TParams _params;

  @nonVirtual
  @pragma('vm:prefer-inline')
  FutureOr<void> restartService(TParams params) {
    _params = params;
    return _restartDebouncer.call();
  }

  late final _restartDebouncer = Debouncer(
    delay: Duration.zero,
    onWaited: () => consec(dispose(), (_) => init(_params)),
  );

  // --- DISPOSAL OF SERVICE ---------------------------------------------------

  @mustCallSuper
  TServiceListeners<TParams> provideDisposeListeners() => [];

  @protected
  @nonVirtual
  FutureOr<void> dispose() {
    if (_state == _ServiceState.DISPOSED || _state == _ServiceState.BUSY_DISPOSING) {
      return _operationFinisher.map((f) => f.resolvable().value).unwrapOr(const Ok(None()));
    }

    if (_state == _ServiceState.NOT_INITIALIZED) {
      _state = _ServiceState.DISPOSED;
      return const None();
    }

    return consec(_operationFinisher.map((f) => f.resolvable().value).unwrapOr(const Ok(None())),
        (_) {
      _state = _ServiceState.BUSY_DISPOSING;
      _operationFinisher = Some(SafeFinisher<None>());

      try {
        final sequential = Sequential();
        sequential.addAll([
          ...provideDisposeListeners().map((e) => (_) => e(_params)),
          (_) => _state = _ServiceState.DISPOSED,
        ]);

        return consec(
          sequential.last,
          (_) {
            _operationFinisher.ifSome((f) => f.unwrap()..finish(const None()));
          },
          onError: (e) {
            _state = _ServiceState.DISPOSED;
            _operationFinisher.ifSome((f) => f.unwrap()..resolve(Sync.value(Err(e))));
          },
        );
      } catch (e) {
        _state = _ServiceState.DISPOSED;
        _operationFinisher.ifSome((f) => f.unwrap()..resolve(Sync.value(Err(e))));
        rethrow;
      }
    });
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TServiceListeners<T> = List<FutureOr<void> Function(T data)>;

// //.title
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //
// // Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// // source code is governed by an MIT-style license described in the LICENSE
// // file located in this project's root directory.
// //
// // See: https://opensource.org/license/mit
// //
// // ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
// //.title~

// import 'package:df_debouncer/df_debouncer.dart';

// import '/src/_common.dart';

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// /// A base class for services that require initialization and disposal
// /// management.
// ///
// /// This class is intended to be used within a Dependency Injection [DI] system.
// ///
// /// It provides a standardized structure for managing the lifecycle of services,
// /// ensuring they are properly initialized when needed and disposed of when no
// /// longer in use.
// abstract class Service<TParams extends Option> {
//   //
//   //
//   //

//   static Resolvable<None> unregister(Result<Service> e) {
//     return Resolvable(() async {
//       await e.unwrap().dispose();
//       return const None();
//     });
//   }

//   //
//   //
//   //

//   Service();

//   // Used to avoid concurrent initialization, resetting, and disposal.
//   final _sequential = Sequential();

//   // --- INITIALIZATION OF SERVICE ---------------------------------------------

//   bool _initialized = false;
//   bool get initialized => _initialized;

//   /// Initializes and re-initializes this service, making it ready for use.
//   @nonVirtual
//   FutureOr<void> init(TParams params) {
//     if (_disposed) {
//       throw Err('Service has already been initialized.');
//     }
//     _sequential.addAll([
//       // Call init listeners.
//       ...provideInitListeners().map(
//         (e) => (_) => e(params),
//       ),
//       (_) {
//         // Mark the service as initialized.
//         _initialized = true;
//       },
//     ]);
//     return _sequential.last;
//   }

//   @mustCallSuper
//   TServiceListeners<TParams> provideInitListeners() => [];

//   // --- RESTARTING OF SERVICE -------------------------------------------------

//   late TParams _params;

//   @nonVirtual
//   @pragma('vm:prefer-inline')
//   FutureOr<void> restartService(TParams params) async {
//     _params = params;
//     return _restartDebouncer.call();
//   }

//   // Used to avoid restarting the service multiple times in quick succession.
//   late final _restartDebouncer = Debouncer(
//     delay: Duration.zero,
//     onWaited: () => init(_params),
//   );

//   // --- DISPOSAL OF SERVICE ---------------------------------------------------

//   /// Whether the service has been disposed.
//   @pragma('vm:prefer-inline')
//   bool get disposed => _disposed;

//   bool _disposed = false;

//   @mustCallSuper
//   TServiceListeners<void> provideDisposeListeners() => [];

//   /// Disposes of this service, making it unusable and ready for garbage
//   /// collection.
//   ///
//   /// Do not call this method directly.
//   @protected
//   @nonVirtual
//   FutureOr<void> dispose() {
//     // Throw an exception if the service has already been disposed.
//     if (_disposed) {
//       throw Err('Service has already been disposed.');
//     }
//     _sequential.addAll([
//       // Call dispose listeners.
//       ...provideDisposeListeners().map(
//         (e) => (_) => e(null),
//       ),
//       (_) {
//         // Mark the service as disposed.
//         _disposed = true;
//       },
//     ]);
//     return _sequential.last;
//   }
// }

// // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// typedef TServiceListeners<T> = List<FutureOr<void> Function(T data)>;

// Source: ./lib/src/core/services/stream_service.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

abstract class StreamService<TData extends Object, TParams extends Option>
    extends Service<TParams> {
  StreamService();

  Option<SafeFinisher<TData>> _initialDataFinisher = const None();
  Option<StreamSubscription<TData>> _streamSubscription = const None();
  Option<StreamController<TData>> _streamController = const None();

  @mustCallSuper
  @override
  TServiceListeners<TParams> provideInitListeners() {
    return [...super.provideInitListeners(), _initListener];
  }

  FutureOr<void> _initListener(TParams params) {
    return consec(_disposeStreamResources(), (_) {
      _initialDataFinisher = Some(SafeFinisher<TData>());
      final controller = StreamController<TData>.broadcast();
      _streamController = Some(controller);
      _streamSubscription = Some(
        provideInputStream(params).listen(
          pushToStream,
          onError: (Object e, StackTrace s) => onError(e, s, dispose),
          cancelOnError: false,
        ),
      );
    });
  }

  @mustCallSuper
  @override
  TServiceListeners<void> provideDisposeListeners() {
    return [
      ...super.provideDisposeListeners(),
      (_) => _disposeStreamResources(),
    ];
  }

  FutureOr<void> _disposeStreamResources() {
    final sub = _streamSubscription;
    _streamSubscription = const None();

    final controller = _streamController;
    _streamController = const None();
    _initialDataFinisher = const None();

    return consec(sub.map((s) => s.cancel()).unwrapOr(), onError: (_) {
      controller.ifSome((c) {
        if (!c.unwrap().isClosed) {
          c.unwrap().close();
        }
      });
    });
  }

  Stream<TData> provideInputStream(TParams params);

  final _listenerQueue = SafeSequential();

  @nonVirtual
  @mustCallSuper
  void pushToStream(TData data) {
    _streamController.ifSome((controller) {
      if (controller.isClosed) return;

      if (shouldAdd(data)) {
        controller.add(data);
        _initialDataFinisher.ifSome((f) => f.finish(data));

        _listenerQueue.addAllSafe(
          provideOnPushToStreamListeners().map((listener) {
            return (_) => Resolvable(() => consec(listener(data), (_) => const None()));
          }),
        );
      }
    });
  }

  void onError(Object e, StackTrace s, FutureOr<void> Function() dispose) {
    print('Error in StreamService source stream for $runtimeType: $e\n$s');
  }

  @mustCallSuper
  TServiceListeners<TData> provideOnPushToStreamListeners() => [];

  bool shouldAdd(TData data) => true;

  Resolvable<TData> get initialData {
    return _initialDataFinisher.map((finisher) {
      return finisher.resolvable().flatMap((value) => value);
    }).unwrapOr(
      Sync.value(Err('initialData accessed before service was initialized.')),
    );
  }

  Option<Stream<TData>> get stream => _streamController.map((c) => c.stream);
}

// Source: ./lib/src/_common.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// Common exports for internal use.

export 'dart:async';

export 'package:collection/collection.dart';
export 'package:df_safer_dart/df_safer_dart.dart';
export 'package:df_type/df_type.dart';
export 'package:meta/meta.dart';

export '_src.g.dart';

export 'core/di/_di_registry.dart';
export 'core/di/_dependency.dart';
export 'core/di/_di_base.dart';

export 'core/di/_mixins/_mixins.g.dart';

// Source: ./lib/src/additional/world.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'package:equatable/equatable.dart';

// import '../core/di/_dependency.dart';
// import '../core/di/_di_registry.dart';
// import '../core/entity/entity.dart';
// import '../core/entity/type_entity.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Manages entities and their associated components,  facilitating the
/// creation, addition, querying, updating, and removal of components within an
/// Entity-Component-System (ECS) framework.
class World {
  /// Internal registry that holds and manages dependencies for components.
  final _di = DIRegistry();

  World();

  /// Used to generate unique dependency IDs.
  static int _dependencyCount = 0;

  /// Returns a new unique ID for a dependency.
  static int _newUniqueId() => _dependencyCount++;

  /// Creates a new [WorldEntity] with a unique ID.
  WorldEntity createUniqueEntity() => WorldEntity._(_newUniqueId(), this);

  /// Adds the [component] to the [entity].
  void addComponent(Entity entity, Component component) {
    _di.setDependency(
      Dependency(
        SyncOk.value(component),
        metadata: Some(
          DependencyMetadata(
            groupEntity: entity,
            preemptivetypeEntity: TypeEntity(component.runtimeType),
            index: Some(_dependencyCount),
          ),
        ),
      ),
    );
  }

  /// Adds all [components] to the [entity].
  void addAllComponents(Entity entity, Set<Component> components) {
    for (final component in components) {
      addComponent(entity, component);
    }
  }

  /// Returns the entities that have the specified component.
  Iterable<WorldEntity> withComponent<T extends Component>() {
    return _di.dependenciesWhereType<T>().map(
          (e) => e.metadata.unwrap().groupEntity as WorldEntity,
        );
  }

  /// Updates the component of type [T] for the given entity.
  /// Returns an [Ok] with the updated component or an [Err] if the component
  /// does not exist.
  Result<Component> updateComponent<T extends Component>(
    Entity entity,
    T newComponent,
  ) {
    final dependency = _di.getDependency<T>(groupEntity: entity);
    if (dependency.isSome()) {
      _di.setDependency(
        Dependency<T>(
          SyncOk.value(newComponent),
          metadata: dependency.unwrap().metadata,
        ),
      );
      return Ok(newComponent);
    } else {
      return Err('Component of type $T does not exist for entity $entity.');
    }
  }

  /// Removes the given entity and its associated components from the registry.
  void removeEntity(Entity entity) {
    _di.removeGroup(groupEntity: entity);
  }

  /// Queries entities that satisfy all the provided conditions.
  ///
  /// ```dart
  /// final results = query([
  ///       withComponent<Name>,
  ///       withComponent<Position>,
  ///       withComponent<Velocity>,
  ///     ])
  /// ```
  Set<WorldEntity> query(List<Iterable<WorldEntity> Function()> queries) {
    Set<WorldEntity>? result;
    for (final query in queries) {
      final t1 = query().toSet();
      result ??= t1;
      if (result != t1) {
        result = result.intersection(t1);
      }
    }
    return result ?? {};
  }

  /// Queries entities that have the specified component [T1].
  Iterable<WorldEntity> query1<T1 extends Component>() {
    return query([withComponent<T1>]);
  }

  /// Queries entities that have both the specified components [T1] and [T2].
  Iterable<WorldEntity> query2<T1 extends Component, T2 extends Component>() {
    return query([withComponent<T1>, withComponent<T2>]);
  }

  /// Queries entities that have the specified components [T1], [T2], and [T3].
  Iterable<WorldEntity> query3<T1 extends Component, T2 extends Component, T3 extends Component>() {
    return query([withComponent<T1>, withComponent<T2>, withComponent<T3>]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3], and
  /// [T4].
  Iterable<WorldEntity> query4<T1 extends Component, T2 extends Component, T3 extends Component,
      T4 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
    ]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3],
  /// [T4], and [T5].
  Iterable<WorldEntity> query5<T1 extends Component, T2 extends Component, T3 extends Component,
      T4 extends Component, T5 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
      withComponent<T5>,
    ]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3],
  /// [T4], [T5], and [T6].
  Iterable<WorldEntity> query6<T1 extends Component, T2 extends Component, T3 extends Component,
      T4 extends Component, T5 extends Component, T6 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
      withComponent<T5>,
      withComponent<T6>,
    ]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3],
  /// [T4], [T5], [T6], and [T7].
  Iterable<WorldEntity> query7<T1 extends Component, T2 extends Component, T3 extends Component,
      T4 extends Component, T5 extends Component, T6 extends Component, T7 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
      withComponent<T5>,
      withComponent<T6>,
      withComponent<T7>,
    ]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3],
  /// [T4], [T5], [T6], [T7], and [T8].
  Iterable<WorldEntity> query8<
      T1 extends Component,
      T2 extends Component,
      T3 extends Component,
      T4 extends Component,
      T5 extends Component,
      T6 extends Component,
      T7 extends Component,
      T8 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
      withComponent<T5>,
      withComponent<T6>,
      withComponent<T7>,
      withComponent<T8>,
    ]);
  }

  /// Queries entities that have the specified components [T1], [T2], [T3],
  /// [T4], [T5], [T6], [T7], [T8], and [T9].
  Iterable<WorldEntity> query9<
      T1 extends Component,
      T2 extends Component,
      T3 extends Component,
      T4 extends Component,
      T5 extends Component,
      T6 extends Component,
      T7 extends Component,
      T8 extends Component,
      T9 extends Component>() {
    return query([
      withComponent<T1>,
      withComponent<T2>,
      withComponent<T3>,
      withComponent<T4>,
      withComponent<T5>,
      withComponent<T6>,
      withComponent<T7>,
      withComponent<T8>,
      withComponent<T9>,
    ]);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents an entity with components in the ECS/World system. Manages
/// dependencies and allows retrieval of a specific component.
final class WorldEntity extends Entity {
  final World world;
  const WorldEntity._(super.value, this.world);

  /// Retrieves all dependencies (components) associated with this entity.
  Iterable<Dependency> _getDependencies<T extends Object>() {
    return world._di.getGroup(groupEntity: this).values;
  }

  /// Retrieves the component of type [T] associated with this entity.
  Option<T> getComponent<T extends Object>() {
    return Option.fromNullable(
      _getDependencies().map((e) => e.value.unwrap()).whereType<T>().firstOrNull,
    );
  }

  /// Returns the entity itself.
  Entity getEntity() => this;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A base class for components that are equatable.
/// Components should extend this class to be used in the ECS system.
abstract class Component extends Equatable {
  const Component();
}

// Source: ./lib/src/_src.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './core/di/di.dart';
export './core/entity/reserved_entities.dart';
export './core/entity/type_entity.dart';
export './core/entity/entity.dart';
export './core/entity/unique_entity.dart';
export './core/services/service.dart';
export './core/services/stream_service.dart';
export './additional/world.dart';

